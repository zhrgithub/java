1.IO通信模型
  IO指的是input和output
  网络通信的本质是网络间的数据IO。只要有IO,就会有阻塞或非阻塞的问题，无论这个IO是网络的，还是硬盘的。原因在于程序是运行在系统上的，任何形式的IO操作都需要系统支持。

2.BIO(阻塞模式)
	  BIO即Blocking IO,是一种阻塞式的IO。
	  jdk1.4版本之前的Socket即BIO模式。
	  BIO的问题在于accept()、read()的操作点都是被阻塞的。
  	  服务器线程发起一个accept动作，询问操作系统是否有新的socket信息从端口X发送过来。注意，是询问操作系统。如果操作系
统没有发现有socket从指定的端口X来，那么操作系统就会等待。这样serverSocket.accept()方法就会一直等待。这就是为什么accept()方法为什么会阻塞。
      如果想让BIO同时处理多个客户端请求，就必须使用多线程，即每次accept阻塞等待来自客户端请求，一旦收到连接请求就建
立通信，同时开启一个新的线程来处理这个套接字的数据读写请求，然后立刻又继续accept等待其他客户端连接请求，即为每一位客户端连接请求都创建一个线程来单独处理。

3.NIO(非阻塞模式)
   NIO即non-blocking IO,是一种非阻塞式的IO。jdk1.4之后提供。
   NIO三大核心部分：Channel(通道)，Buffer（缓冲区），Selector（选择器）。
   Buffer：容器对象，包含一些要写入或者读出的数据。在NIO库，所有数据都是用缓冲区处理的。在读取数据时，它是直接读取到缓
冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据。都是通过缓冲区进行操作。
   Channel:通道对象，对数据的读取和写入要通过Channel,它就像水管一样。通道不同于流的地方就是通道是双向的，可以用于读、
写和同时读写操作。Channel不会直接处理字节数据，而是通过Buffer对象来处理数据。
   Selector:多路复用器，选择器。提供选择已经就绪的任务的能力。Selector会不断轮询注册在其上的Channel，如果某个Channe
l上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，进行后续的I/O操作。这样服务器只需要一两个线程就可以进行多客户端通信。

4.阻塞/非阻塞、同步/非同步
   阻塞IO和非阻塞IO这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序如何处
理的问题：前者等待；后者继续执行（并且使用线程一直轮询，直到有IO资源准备好了）。
  
   同步IO和非同步IO,这两个概念是操作系统级别。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如
何响应程序的问题：前者不响应，直到IO资源准备好以后；后者返回一个标记（好让程序和自己知道以后的数据往哪里通知），当
IO资源准备好以后，再用事件机制返回给程序。
 
  


