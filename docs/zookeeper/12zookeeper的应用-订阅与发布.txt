1.数据订阅与发布（配置中心）
    服务器端：集群的存储（db地址 密码等信息）;
    客户端：一般为订单、购物车、秒杀
	注意：统一管理数据不能太大
2.过程
   2.1）所有订阅者初次启动的时候去zk指定的节点获取相关的订阅信息（数据库相关信息）
   2.2）获取数据的同时，还要设置监听(watcher)，监听节点数据的变化。
         zk.getData("/emall/dbdata")
         zk.getData("/eamll/dbdata",true)
   2.3）一旦节点数据发生变化，监听就会被触发，我们的各个应用（订阅者，相对于zk来说就是客户端）就会收到事件的通知，从而去获取新的配置信息
   2.4）还要再次设置相同的监听
3.命名服务
	3.1）在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者的地址，提供者等信息。
	3.2）被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等待--这些我们都可以统称它们为名字。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用zk提供的创建节点的api,能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。
	3.3）阿里巴巴集团开源的分布式服务架构Dobbo中使用zookeeper来作为其命名服务，维护全局的服务地址列表
4.分布式锁
    4.1）分布式锁，这个主要得益于zookeeper	保证了数据的一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序
    4.2）保持独占：
    			1）所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。
    			2）通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建/distribute_lock节点，最终成功创建的那个客户端也即拥有了这把锁
    4.3）控制时序：
              1）所有试图获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。
              2）做法和上面基本类似，只是这里/distribute_lock已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。
              3）Zk的父节点（/distribute_lock）维持一份sequence，保证子节点创建的时序性，从而也形成了
              每个客户端的全局时序。



