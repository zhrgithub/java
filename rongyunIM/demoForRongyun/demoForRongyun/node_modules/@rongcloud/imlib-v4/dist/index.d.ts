import { MessageDirection, IReadReceiptInfo, NotificationStatus, ConversationType, IReceivedMessage, APIContext, IConversationOption, ISendMsgOptions, IUserProfile, IPushConfig, IMessageReaderResponse, IConversationTag, ITagParam, ITagInfo, ErrorCode, IChatroomInfo, RTCMode, IJoinRTCRoomData, IRTCRoomInfo, RTCApiType, KVString, IRTCUsers, IRtcTokenData, INaviInfo, ConnectionStatus, IChatroomListenerData, IExpansionListenerData, ITypingMessage, IBlockedMessageInfo, LogLevel, IPluginGenerator, FileType, IUploadAuth, UploadMethod, ChatroomEntryType } from '@rongcloud/engine';
export { ChatroomEntryType, ConnectionStatus, ConversationType, FileType, IChatroomInfo, IChatroomListenerData, IConversationOption, IDeletedExpansion, IExpansionListenerData, ISendMsgOptions, IUpdatedExpansion, LogLevel, MessageDirection, NotificationStatus, UploadMethod } from '@rongcloud/engine';

declare const ERROR_CODE: {
    [key in number | string]: number | string;
};

declare const CONNECTION_STATUS: {
    CONNECTED: number;
    CONNECTING: number;
    DISCONNECTED: number;
    NETWORK_UNAVAILABLE: number;
    SOCKET_ERROR: number;
    KICKED_OFFLINE_BY_OTHER_CLIENT: number;
    BLOCKED: number;
};

/**
 * 业务层枚举, 此处枚举会暴露给开发者
*/
declare const CONNECT_TYPE: {
    COMET: string;
    WEBSOCKET: string;
};
declare const MESSAGS_TIME_ORDER: {
    DESC: number;
    ASC: number;
};
declare const CHATROOM_ORDER: {
    ASC: number;
    DESC: number;
};
declare const RECALL_MESSAGE_TYPE = "RC:RcCmd";
declare const MENTIONED_TYPE: {
    ALL: number;
    SINGAL: number;
};
declare const MESSAGE_TYPE: {
    TEXT: string;
    VOICE: string;
    HQ_VOICE: string;
    IMAGE: string;
    GIF: string;
    RICH_CONTENT: string;
    LOCATION: string;
    FILE: string;
    SIGHT: string;
    COMBINE: string;
    CHRM_KV_NOTIFY: string;
    LOG_COMMAND: string;
    EXPANSION_NOTIFY: string;
    REFERENCE: string;
};
declare const RECEIVED_STATUS: {
    READ: number;
    LISTENED: number;
    DOWNLOADED: number;
    RETRIEVED: number;
    UNREAD: number;
};
declare const SDK_VERSION: string;

declare type GetHistoryMessageOption = {
    /**
     * 获取此时间之前的消息，0 为从当前时间拉取
     */
    timestamp?: number;
    /**
     * 获取消息的数量，范围: 1-20
     */
    count?: number;
    /**
     * 获取消息的排列顺序
     * * 0: 升序
     * * 1: 降序
     */
    order?: 0 | 1;
};
/**
 * 用户收到的消息结构
 */
interface IAReceivedMessage {
    /**
     * 消息类型
     * @example RC:TxtMsg
     */
    messageType: string;
    /**
     * 消息内容
     */
    content: Object;
    /**
     * 消息发送者的用户 id
     */
    senderUserId: string;
    /**
     * 会话 id
     */
    targetId: string;
    /**
     * 会话类型
     * * 1: 单聊
     * * 3: 群聊
     * * 4: 聊天室
     * * 5: 客服会话
     * * 6: 系统消息
     * * 7: 默认关注的公众号
     * * 8: 手动关注的公众号
     * * 9: RTCLib 房间
     */
    type: number;
    /**
     * 消息在服务器端的发送时间
     */
    sentTime: number;
    /**
     * 消息接收时间，该时间通过消息的 `sentTime` 值在本地进行计算得出，不推荐使用
     * @description 当 isOffLineMessage 为 true 时，该值无效
     */
    receivedTime: number;
    /**
     * 服务端存储的消息 Id
     */
    messageUId: string;
    /**
     * 消息方向
     * * 1: 发送
     * * 2: 接收
     */
    messageDirection: MessageDirection;
    /**
     * 是否存储
     * @default true
     */
    isPersited: boolean;
    /**
     * 是否计数
     * @default true
     */
    isCounted: boolean;
    /**
     * 是否为离线消息
     */
    isOffLineMessage: boolean;
    /**
     * 是否为 @ 消息
     */
    isMentioned?: boolean;
    /**
     * 消息是否静默
     * @description 静默消息不会发送 Push 信息和本地通知提醒
     */
    disableNotification?: boolean;
    /**
     * 是否是状态消息
     */
    isStatusMessage?: boolean;
    /**
     * 是否支持消息扩展
    */
    canIncludeExpansion: boolean;
    /**
     * 消息扩展
    */
    expansion?: {
        [key: string]: any;
    } | null;
    /**
     * 消息接收状态
    */
    receivedStatus: number;
    /**
     * 消息已读回执信息，导航配置grpRRVer=1时群组类型消息内存在, 其他情况为undefined
     */
    readReceiptInfo?: IReadReceiptInfo;
}
declare type GetHistoryMessageResult = {
    list: IAReceivedMessage[];
    hasMore: boolean;
};
interface IConversationUpdateItem {
    time: number;
    val: any;
}
declare type MentionedInfo = {
    /**
     * `@ 类型，其中 1 为 @ 所有人，2 为 @ 部分人`
     */
    type?: 1 | 2;
    /**
     * 被 @ 的用户 Id 列表，仅在 `type` 为 `2` 时有效
     */
    userIdList?: Array<string>;
};
/**
 * 用户收到的会话结构
 */
interface IAReceivedConversation {
    /**
     * 会话类型
     * * 1: 单聊
     * * 3: 群聊
     * * 4: 聊天室
     * * 5: 客服会话
     * * 6: 系统消息
     * * 7: 默认关注的公众号
     * * 8: 手动关注的公众号
     * * 9: RTCLib 房间
     */
    type: number;
    /**
     * 会话 id
     */
    targetId: string;
    /**
     * 会话中的最后一条消息
     */
    latestMessage: IAReceivedMessage | null;
    /**
     * 当前会话的未读消息数
     */
    unreadMessageCount?: number;
    /**
     * 是否包含 @ 自己的消息
     * @description 仅在 `conversationType` 为 `ConversationType.GROUP` 时有效
     */
    hasMentioned?: boolean;
    /**
     * 消息中的 @ 数据
     * @description 仅在 `conversationType` 为 `ConversationType.GROUP` 时有效
     */
    mentionedInfo?: MentionedInfo;
    /**
     * 会话中消息的最后未读时间
     */
    lastUnreadTime?: number;
    /**
     * 会话免打扰状态
     * * 1: 开启免打扰
     * * 2: 关闭免打扰
     */
    notificationStatus?: NotificationStatus;
    /**
     * 会话是否置顶
     */
    isTop?: boolean;
}
interface IReceivedUpdateConversation {
    updatedItems: {
        [key: string]: IConversationUpdateItem;
    };
    type: number;
    targetId: string;
    latestMessage?: IAReceivedMessage;
    unreadMessageCount?: number;
    hasMentioned?: boolean;
    mentionedInfo?: MentionedInfo;
    lastUnreadTime?: number;
    notificationStatus?: NotificationStatus;
    isTop?: boolean;
}
interface IConversationMergeOption {
    conversationList: IAReceivedConversation[];
    updatedConversationList: IReceivedUpdateConversation[];
}
interface IConversationContainTag {
    channelId?: string;
    conversationType: ConversationType;
    targetId: string;
    unreadMessageCount: number;
    latestMessage: IReceivedMessage | null;
    hasMentioned?: boolean;
    mentionedInfo?: {
        type: 1 | 2;
        userIdList: string[];
    } | null;
    notificationStatus: NotificationStatus;
    isTop: boolean;
    isTopInTag: boolean;
    lastUnreadTime: number;
}

declare class Conversation {
    private readonly _context;
    /**
     * 会话 id
     */
    readonly targetId: string;
    /**
     * 会话类型
     */
    readonly type: ConversationType;
    constructor(_context: APIContext, option: IConversationOption);
    /**
     * 删除指定会话
     */
    destory(): Promise<void>;
    /**
     * 清除会话未读数
     */
    read(): Promise<void>;
    /**
     * 获取指定会话未读数
     */
    getUnreadCount(): Promise<number>;
    /**
     * 发送消息
     * @param options
     * @deprecated options.isPersited
     * @deprecated options.isCounted
     * @deprecated options.isStatusMessage
     */
    send(options: ISendMsgOptions): Promise<IAReceivedMessage>;
    /**
     * 设置会话状态
     */
    setStatus(status: {
        /**
         * 是否免打扰
         * * 1: 开启免打扰
         * * 2: 关闭免打扰
         */
        notificationStatus?: NotificationStatus;
        /**
         * 是否置顶
         */
        isTop?: boolean;
    }): Promise<void>;
    /**
     * 获取历史消息
     */
    getMessages(options: GetHistoryMessageOption): Promise<GetHistoryMessageResult>;
    /**
     * 撤回消息
     * @param options
     */
    recall(options: {
        /**
         * 消息的唯一id，客户端依赖此属性查找要撤回的消息
         */
        messageUId: string;
        /**
         * 消息发送时间，服务端依赖此属性查找要撤回的消息
         */
        sentTime: number;
        /**
         * 撤回消息携带用户信息
        */
        user?: IUserProfile;
        /**
          * 是否发送静默消息
          * @description
          * 当值为 `true` 时，服务器将不会发送 Push 信息，移动端也不会弹出本地通知提醒
        */
        disableNotification?: boolean;
        /**
         * 移动端推送配置
        */
        pushConfig?: IPushConfig;
    }): Promise<IAReceivedMessage>;
    /**
     * 按消息 id 删除消息
     */
    deleteMessages(messages: {
        /**
         * 消息 id
         */
        messageUId: string;
        /**
         * 消息发送时间
         */
        sentTime: number;
        /**
         * 消息方向
         * * 1: 发送
         * * 2: 接收
         */
        messageDirection: MessageDirection;
    }[]): Promise<void>;
    /**
     * 按时间戳删除消息
     */
    clearMessages(options: {
        /**
         * 清除时间点, 该时间之前的消息将被清除
         */
        timestamp: number;
    }): Promise<void>;
    /**
     * 更新（添加、替换）消息扩展属性
     * @param expansion 要更新的消息扩展信息键值对
     * @param message 要更新的原始消息体
    */
    updateMessageExpansion(expansion: {
        [key: string]: any;
    }, message: IAReceivedMessage): Promise<void>;
    /**
     * 删除扩展存储
     * @params keys 需删除消息扩展的 keys
     * @params message 原始消息体
    */
    removeMessageExpansion(keys: string[], message: IAReceivedMessage): Promise<void>;
    /**
     * 设置会话文本草稿
     * @params conversationType 会话乐行
     * @params targetId 目标 ID
     * @params draft 草稿内容
    */
    setDraft(draft: string): Promise<void>;
    /**
     * 获取会话文本草稿
     * @params conversationType 会话乐行
     * @params targetId 目标 ID
    */
    getDraft(): Promise<string>;
    /**
     * 删除会话文本草稿
     * @params conversationType 会话乐行
     * @params targetId 目标 ID
    */
    deleteDraft(): Promise<void>;
    /**
     * 发送群已读回执（需要导航‘grpRRVer’为1）
     * @param messageUIds 消息UID列表
     */
    sendReadReceiptMessage(messageUIds: string[]): Promise<void>;
    /**
     * 发送typing消息
     * @param typingContentType 输入状态消息类型
     * @returns
     */
    sendTypingStatusMessage(typingContentType: string): Promise<IAReceivedMessage>;
    /**
     * 获取群已读列表
     * @param messageUId 消息UID
     * @returns
     */
    getMessageReader(messageUId: string): Promise<IMessageReaderResponse>;
    /**
     * 获取会话信息
     * @returns
     */
    getInfo(): Promise<IAReceivedConversation>;
    removeTags(tagIds: string[]): Promise<number>;
    /**
     * 获取会话的标签
     * @returns
     */
    getTags(): Promise<IConversationTag[]>;
}
declare class ConversationModule {
    private _context;
    constructor(apiContext: APIContext);
    /**
     * 获取会话列表
     * @param options
     */
    getList(options: {
        /**
         * 会话数量
         */
        count?: number;
        /**
         * 获取起始时间
         * 默认值: 0
         * order 为 0 startTime 默认值为当前时间
         * order 为 1 startTime 默认值为所有会话中最早的消息时间
        */
        startTime?: number;
        /**
         * 默认值: 0
         * 0 获取 startTime 之前的
         * 1 获取 startTime 之后的
        */
        order?: 0 | 1;
    }): Promise<IAReceivedConversation[]>;
    /**
     * 获取指定会话实例，通过实例可实现向指定会话收发消息等功能
     * @description 通过该方法获取的会话可能并不存在于当前的会话列表中，此处只作为功能性封装语法糖
     * @param options
     */
    get(options: IConversationOption): Conversation;
    remove(options: IConversationOption): Promise<void>;
    /**
     * 获取当前所有会话的消息未读数
     * @description
     * 1. 清除浏览器缓存会导致会话未读数不准确
     * 2. 会话消息未读数存储在 WebStorage 中, 若浏览器不支持或禁用 WebStorage，未读消息数将不会保存，浏览器页面刷新未读消息数将不会存在
     * 3. 其他端删除会话可能会导致会话未读数不准确
     * @param includeMuted 是否包含免打扰会话
     * @param conversationTypes 要获取未读数的会话类型，若为空，则默认获取单聊、群聊及系统消息未读数
     */
    getTotalUnreadCount(includeMuted?: boolean, conversationTypes?: ConversationType[]): Promise<number>;
    /**
     * 合并会话
     * @param option
     */
    merge(option: IConversationMergeOption): any[];
}

declare class Tag {
    private readonly _context;
    readonly tagId: string;
    constructor(_context: APIContext, tagId: string);
    /**
     * 更新标签
     * @param tagName 标签名称
     * @returns
     */
    update(tagName: string): Promise<number>;
    /**
     * 删除标签
     * @returns
     */
    remove(): Promise<number>;
    /**
     * 给标签添加多个会话
     * @param conversations 会话数组
     * @returns
     */
    addConversations(conversations: IConversationOption[]): Promise<number>;
    /**
     * 删除标签中的多个会话
     * @param conversations 会话数组
     * @returns
     */
    removeConversations(conversations: IConversationOption[]): Promise<number>;
    /**
     * 获取标签下的多个会话
     * @param startTime 会话时间戳
     * @param count 会话数量
     * @returns
     */
    getConversationList(startTime: number, count?: number): Promise<IConversationContainTag[] | undefined>;
    /**
     * 获取标签下的消息未读数
     * @param isIncludeNotNotification 是否包含免打扰
     * @returns
     */
    getUnreadCount(isIncludeNotNotification: boolean): Promise<number>;
    /**
     * 设置标签中会话置顶
     * @param conversation 置顶会话
     * @param isTop
     * @returns
     */
    updateConversationIsTop(conversation: IConversationOption, isTop: boolean): Promise<ErrorCode.SUCCESS>;
}
declare class TagModule {
    private _context;
    constructor(apiContext: APIContext);
    /**
     *创建标签
     * @param tag 标签对象
     * @returns
     */
    create(tag: ITagParam): Promise<number>;
    /**
     * 获取标签列表
     * @returns
     */
    getTagInfoList(): Promise<Array<ITagInfo>>;
    /**
     * 获取标签
     * @param tagId 标签ID
     * @returns
     */
    get(tagId: string): Promise<Tag>;
}

declare type ISetChatroomEntryOption = {
    key: string;
    value: string;
    isAutoDelete?: boolean;
    isSendNotification?: boolean;
    notificationExtra?: string;
};
declare type ISetChatroomEntriesOption = {
    entries: {
        key: string;
        value: string;
    }[];
    isAutoDelete?: boolean;
    notificationExtra?: string;
};
declare type IRemoveChatroomEntryOption = {
    key: string;
    isSendNotification?: boolean;
    notificationExtra?: string;
};
declare class Chatroom {
    private readonly _context;
    private _id;
    constructor(context: APIContext, id: string);
    /**
     * 加入聊天室
     */
    join(options: {
        /**
         * 拉取消息数
         */
        count: number;
    }): Promise<void>;
    /**
     * 加入已存在的聊天室
     */
    joinExist(options: {
        /**
         * 拉取消息数
         */
        count: number;
    }): Promise<void>;
    /**
     * 退出聊天室
     */
    quit(): Promise<void>;
    /**
     * 获取聊天室房间数据
     * @description count 或 order 有一个为 0 时，只返回成员总数，不返回成员列表信息
     */
    getInfo(options?: {
        /**
         * 获取聊天室的人数，传值范围：0-20，默认为 0
         */
        count?: number;
        /**
         * 聊天室的人员排序，默认为 0
         * * 1: 升序
         * * 2: 降序
         */
        order?: 0 | 1 | 2;
    }): Promise<IChatroomInfo>;
    /**
     * 设置聊天室自定义属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     */
    setEntry(options: ISetChatroomEntryOption): Promise<void>;
    /**
     * 批量设置聊天室自定义属性
     * @param options ISetChatroomEntryOption数组
     */
    setEntries(options: ISetChatroomEntriesOption): Promise<void>;
    /**
     * 强制 增加/修改 任意聊天室属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     */
    forceSetEntry(options: ISetChatroomEntryOption): Promise<void>;
    /**
     * 删除聊天室属性
     * @description 仅限于删除自己设置的聊天室属性
     * @param key 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     * @param isSendNotification? 删除成功后是否发送通知消息
     * @param notificationExtra? RC:chrmKVNotiMsg 通知消息中携带的附加信息
     */
    removeEntry(options: IRemoveChatroomEntryOption): Promise<void>;
    /**
     * 批量删除聊天室属性
     * @description 仅限于删除自己设置的聊天室属性
     * @param options entries属性集合, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    removeEntries(options: {
        entries: string[];
    }): Promise<void>;
    /**
     * 强制删除聊天室内的任意属性
     * @description
     */
    forceRemoveEntry(options: IRemoveChatroomEntryOption): Promise<void>;
    /**
     * 获取聊天室的指定属性
     */
    getEntry(key: string
    /**
     * 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    ): Promise<string | number | boolean>;
    /**
     * 获取聊天室的所有属性
     */
    getAllEntries(): Promise<{
        [key: string]: string | number | boolean;
    }>;
    /**
     * 发送消息
     */
    send(options: ISendMsgOptions): Promise<IAReceivedMessage>;
    /**
     * 获取聊天室的历史消息
     */
    getMessages(options: GetHistoryMessageOption): Promise<GetHistoryMessageResult>;
    /**
     * 撤回聊天室消息
    */
    recall(options: {
        /**
         * 消息的唯一id，客户端依赖此属性查找要撤回的消息
         */
        messageUId: string;
        /**
         * 消息发送时间，服务端依赖此属性查找要撤回的消息
         */
        sentTime: number;
        /**
         * 撤回消息携带用户信息
        */
        user?: {
            [key: string]: string;
        };
    }): Promise<IAReceivedMessage>;
}
declare class ChatroomModule {
    private _context;
    constructor(apiContext: APIContext);
    /**
     * 根据聊天室 id 初始化一个聊天室功能实例，以实现收发消息等聊天室相关功能
     * @param option
     */
    get(option: {
        /**
         * 聊天室 id
         */
        id: string;
    }): Chatroom;
}

declare type RTCRoomOption = {
    id: string;
    roomId: string;
    mode: RTCMode;
    broadcastType: number;
};
declare class RTCClient {
    private _options;
    private _context;
    private readonly _roomId;
    constructor(_options: RTCRoomOption, _context: APIContext);
    join(): Promise<IJoinRTCRoomData>;
    quit(): Promise<ErrorCode.SUCCESS>;
    getRoomInfo(): Promise<IRTCRoomInfo>;
    setUserInfo(info: {
        key: string;
        value: string;
    }): Promise<ErrorCode.SUCCESS>;
    removeUserInfo(info: {
        keys: string[];
    }): Promise<ErrorCode.SUCCESS>;
    setData(key: string, value: string, isInner: boolean, apiType: RTCApiType, message: any): Promise<ErrorCode.SUCCESS>;
    setUserData(key: string, value: string, isInner: boolean, message: any): Promise<ErrorCode.SUCCESS>;
    /**
     * 全量 URI 资源发布
     * @param message 旧版本消息，含消息名及消息内容
     * @param valueInfo 全量消息数据
     * @param objectName 全量 URI 消息名
     */
    setRTCUserData(message: {
        name: string;
        content: string;
    }, valueInfo: string, objectName: string): Promise<ErrorCode.SUCCESS>;
    getData(keys: string[], isInner: boolean, apiType: RTCApiType): Promise<KVString>;
    getUserData(keys: string[], isInner: boolean): Promise<KVString>;
    removeData(keys: string[], isInner: boolean, apiType: RTCApiType, message: {
        name: string;
        content: string;
    }): Promise<ErrorCode.SUCCESS>;
    removeUserData(keys: string[], isInner: boolean, message: {
        name: string;
        content: string;
    }): Promise<ErrorCode.SUCCESS>;
    setRoomData(key: string, value: string, isInner: boolean, message: any): Promise<ErrorCode.SUCCESS>;
    getRoomData(keys: string[], isInner: boolean): Promise<KVString>;
    removeRoomData(keys: string[], isInner: boolean, message: {
        name: string;
        content: string;
    }): Promise<ErrorCode.SUCCESS>;
    setState(content: {
        report: string;
    }): Promise<ErrorCode.SUCCESS>;
    getUserList(): Promise<IRTCUsers>;
    getUserInfoList(): Promise<{
        [userId: string]: {
            uris?: string | undefined;
        };
    }>;
    getToken(): Promise<IRtcTokenData>;
    ping(): Promise<ErrorCode.SUCCESS>;
    send(options: {
        messageType: string;
        content: Object;
    }): Promise<IReceivedMessage>;
}

interface IReceivedAppInfo {
    appkey: string;
    token: string;
    navi: INaviInfo | null;
}
interface IWatchOptions {
    /**
     * 用于监听连接状态变更通知
     */
    status?: (event: {
        status: ConnectionStatus;
    }) => void;
    /**
     * 用于监听消息通知
     */
    message?: (event: {
        message: IAReceivedMessage;
    }) => void;
    /**
     * 用于监听会话状态变更通知
     */
    conversation?: (event: {
        updatedConversationList: IReceivedUpdateConversation[];
    }) => void;
    /**
     * 用于监听聊天室状态变更通知
     */
    chatroom?: (event: IChatroomListenerData) => void;
    /**
     * 用于标签变更通知
     */
    tag?: () => void;
    /**
     * 用于监听消息扩展存储
    */
    expansion?: (event: IExpansionListenerData) => void;
    /**
     * 输入状态
     */
    typingStatus?: (event: ITypingMessage[]) => void;
    /**
     * 用于拉取完毕监听
     */
    pullFinished?: () => void;
    /**
     * 用于屏蔽的消息监听
     */
    messageBlocked?: (event: IBlockedMessageInfo) => void;
}
declare type IInitOption = {
    /**
     * 应用 appkey 标识
     */
    appkey: string;
    /**
     * 修改 engine log 打印等级
     */
    logLevel?: LogLevel;
    /**
     * 修改默认的 log 输出函数
     */
    logStdout?: (logLevel: LogLevel, content: string) => void;
    /**
     * 自定义导航地址，公有云用户不推荐修改
     */
    navigators?: string[];
    /**
     * 连接方式，默认使用 'websocket'
     */
    connectType?: 'websocket' | 'comet';
    /**
     * 小程序平台专属配置
     */
    customCMP?: string[];
    /**
     * @deprecated
     */
    detect?: undefined;
    /**
     * @deprecated
     */
    debug?: boolean;
    /**
     * 是否打开 IndexDB 存储, 默认为 true
     */
    indexDBSwitch?: boolean;
    /**
     * 是否校验证书，默认为 true
     */
    checkCA?: boolean;
};
declare class IMClient {
    private readonly _context;
    private _token;
    Conversation: ConversationModule;
    ChatRoom: ChatroomModule;
    Tag: TagModule;
    RTC: (options: RTCRoomOption) => RTCClient;
    constructor(apiContext: APIContext);
    /**
     * 装载 plugin 插件，并返回相应的插件实例，需在调用 `connect` 方法之前使用
     * @param plugins
     */
    install<T, O>(plugin: IPluginGenerator<T, O>, options: O): T | null;
    /**
     * 添加全局事件监听，同一类型事件会覆盖添加，以避免多次监听引起的复杂问题
     * @param options
     */
    watch(options: IWatchOptions): void;
    unwatch(): void;
    rtcInnerWatch(attrs: {
        message?: (event: {
            message: IAReceivedMessage;
        }) => void;
        status?: (event: {
            status: ConnectionStatus;
        }) => void;
    }): void;
    rtcInnerUnwatch(): void;
    /**
     * 建立 IM 连接
     * @param options
     */
    connect(options: {
        /**
         * 用户 token
         */
        token: string;
    }): Promise<{
        id: string;
    }>;
    /**
     * 使用上一次的链接 token 重新建立连接，该方法只需在主动调用 `disconnect` 方法之后有重连需求时调用
     */
    reconnect(): Promise<{
        id: string;
    }>;
    /**
     * 断开当前用户的连接
     * @description 调用后将不再接收消息，不可发送消息，不可获取历史消息，不可获取会话列表
     */
    disconnect(): Promise<void>;
    /**
     * 获取当前 IM 环境信息
     */
    getAppInfo(): IReceivedAppInfo;
    /**
     * 获取 IM 连接时间
     */
    getConnectedTime(): number;
    /**
     * 获取服务器时间
     */
    getServerTime(): number;
    /**
     * 获取 IM 连接状态
     */
    getConnectionStatus(): ConnectionStatus;
    /**
     * 获取 IM 连接用户的 id
     */
    getConnectionUserId(): string;
    /**
     * 获取文件 token
     * @description 上传文件时，获取文件 token
     * @param fileType 上传类型, 通过 RongIMLib.FILE_TYPE 获取
     * @param fileName 上传文件名，Server 通过文件名生成百度上传认证, 若不传 engine 自动生成
     * @param httpMethod STC 分段上传时的必填参数，有效值为 PUT | POST
     * @param queryString STC 分段上传时的查询字符串
     * `httpMethod` 与 `queryString` 为 STC S3 分段上传时的专属参数，STC 分段上传包含三个过程：
     * 1. 开始分段前调用，此时 `httpMethod` 值应为 `POST`， `queryString` 值为 `uploads`，filename为空
     * 2. 上传请求前调用，此时 `httpMethod` 值应为 `PUT`，`queryString` 值为 `partNumber={partamNumer}&uploadId={uploadId}`，filename为第一个步骤生成的filename
     * 3. 上传结束前调用，此时 `httpMethod` 值应为 `POST`，`queryString` 值为 `uploadId={uploadId}`，filename为第一个步骤生成的filename
     */
    getFileToken(fileType: FileType, fileName?: string, httpMethod?: 'PUT' | 'POST', queryString?: string): Promise<IUploadAuth & {
        bos: string;
        qiniu: string;
    }>;
    /**
     * 获取文件的下载地址
     * @param fileType 文件类型
     * @param fileName 文件名
     * @param saveName 下载后的存储文件名
     * @param uploadRes 上传成功返回的数据，百度 bos 上传地址即为下载地址，IM Server 不会返回百度 bos 下载地址，通过用户层传入再返回
     * @param serverType 使用的存储服务标识
     * @returns
     */
    getFileUrl(fileType: FileType, filename?: string, saveName?: string, uploadRes?: {
        isBosRes: boolean;
        downloadUrl: string;
    }, serverType?: UploadMethod): Promise<{
        downloadUrl: string;
    }>;
    /**
     * 切换用户，作用等同于断开当前用户连接，以新的 token 重新建立连接
     * @deprecated
     * @param option
     */
    changeUser(options: {
        /**
         * 用户 token
         */
        token: string;
    }): Promise<{
        id: string;
    }>;
    /**
     * 注册自定义消息
     * @param messageType 消息类型
     * @param isPersited  是否存储
     * @param isCounted   是否计数
     * @param prototypes  消息属性名称
    */
    registerMessageType(messageType: string, isPersited: boolean, isCounted: boolean, prototypes?: string[]): void;
}
/**
 * 初始化
 * @param {IInitOption} options
 */
declare const init: (options: IInitOption) => IMClient;
declare const getInstance: () => IMClient;

/**
 * @deprecated
 */
declare const MESSAGE_DIRECTION: typeof MessageDirection;
/**
 * @deprecated
 */
declare const CONVERSATION_TYPE: typeof ConversationType;
/**
 * @deprecated
 */
declare const FILE_TYPE: typeof FileType;
/**
 * @deprecated
 */
declare const NOTIFICATION_STATUS: {
    DO_NOT_DISTURB: NotificationStatus;
    NOTIFY: NotificationStatus;
};
/**
 * @deprecated
 */
declare const CHATROOM_ENTRY_TYPE: typeof ChatroomEntryType;

export { CHATROOM_ENTRY_TYPE, CHATROOM_ORDER, CONNECTION_STATUS, CONNECT_TYPE, CONVERSATION_TYPE, ERROR_CODE, FILE_TYPE, GetHistoryMessageOption, GetHistoryMessageResult, IAReceivedConversation, IAReceivedMessage, IConversationMergeOption, IConversationUpdateItem, IInitOption, IMClient, IReceivedAppInfo, IReceivedUpdateConversation, IRemoveChatroomEntryOption, ISetChatroomEntryOption, IWatchOptions, MENTIONED_TYPE, MESSAGE_DIRECTION, MESSAGE_TYPE, MESSAGS_TIME_ORDER, NOTIFICATION_STATUS, RECALL_MESSAGE_TYPE, RECEIVED_STATUS, SDK_VERSION, getInstance, init };
