/*
 * RCEngine - v4.5.1
 * CommitId - 54768e91ebac53c7cb4ee3239563db82ff1dffcc
 * Thu Nov 04 2021 11:41:16 GMT+0800 (China Standard Time)
 * ©2020 RongCloud, Inc. All rights reserved.
 */
/**
 * 会话类型
 */
declare enum ConversationType {
    /**
     * 无类型
     */
    NONE = 0,
    /**
     * 单聊
     */
    PRIVATE = 1,
    /**
     * 讨论组
     */
    DISCUSSION = 2,
    /**
     * 群组聊天
     */
    GROUP = 3,
    /**
     * 聊天室会话
     */
    CHATROOM = 4,
    /**
     * 客服会话
     */
    CUSTOMER_SERVICE = 5,
    /**
     * 系统消息
     */
    SYSTEM = 6,
    /**
     * 默认关注的公众号会话类型（MC)
     */
    APP_PUBLIC_SERVICE = 7,
    /**
     * 需手动关注的公众号会话类型（MP)
     */
    PUBLIC_SERVICE = 8,
    /**
     * RTCLib 特有的会话类型
     */
    RTC_ROOM = 12
}

/**
 * 标签相关接口
 */
/**
 * 会话标签
 */
interface IConversationTag {
    tagId: string;
    tagName?: string;
    createdTime?: number;
    isTop?: boolean;
}
/**
 * 标签参数
 */
interface ITagParam {
    tagId: string;
    tagName: string;
}
/**
 * 标签状态
 */
interface ITagStatus {
    isTop?: boolean;
}
/**
 * 本地存储会话的标签状态
 */
interface ILocalTagStatus {
    [tagId: string]: ITagStatus;
}
interface ITagInfo {
    tagId: string;
    tagName: string;
    conversationCount: number;
    createdTime?: number;
}
declare enum TagChangeType {
    add = 1,
    update = 2,
    delete = 3
}

/**
 * 通信协议中 fixHeader 第一个字节中的 Qos 数据标识
 * ```
 * fixHeader：command(4 bit) | dup(1 bit) | Qos(2 bit) | retain(1 bit)
 * ```
 */
declare enum QOS {
    AT_MOST_ONCE = 0,
    AT_LEAST_ONCE = 1,
    EXACTLY_ONCE = 2,
    DEFAULT = 3
}
/**
 * 通信协议中 fixHeader 第一个字节中的 command 数据标识，用于判断操作类型
 * ```
 * fixHeader：command(4 bit) | dup(1 bit) | Qos(2 bit) | retain(1 bit)
 * ```
 */
declare enum OperationType {
    /** 私有云专用，解密协商指令 */
    SYMMETRIC = 0,
    /** 连接请求 */
    CONNECT = 1,
    /** 连接应答 */
    CONN_ACK = 2,
    /** 上行发送消息 */
    PUBLISH = 3,
    /** 上行发送消息的应答 */
    PUB_ACK = 4,
    /** 上行拉消息 */
    QUERY = 5,
    /** 上行拉消息的应答 */
    QUERY_ACK = 6,
    /** QueryConfirm */
    QUERY_CONFIRM = 7,
    SUBSCRIBE = 8,
    SUB_ACK = 9,
    UNSUBSCRIBE = 10,
    UNSUB_ACK = 11,
    PING_REQ = 12,
    PING_RESP = 13,
    /** 连接挂断 */
    DISCONNECT = 14,
    RESERVER2 = 15
}
/**
 * connect 版本号，用于区分 ConnAckMessage 的解析规则
 */
declare enum ConnAckProtocolVer {
    /**
     * V4 说明：
     * ```
     * 增加 flag 来标识每个位置是否有内容，如果没有 messageId 说明此 APP 没有配置防重放，默认取0
     * status            |   4byte
     * flag              |   1byte  每一位标识是否有对应值，由低到高
     * userId            |   可变长
     * sessionId         |   可变长
     * timestamp         |   8byte
     * messageId         |   4byte
     * onlineClientInfo  |   可变长
     * ===
     * flag 描述：
     * | | | |          4          |      3       |       2      |      1       |     0     |
     * | | | | hasOnlineClientInfo | hasMessageId | hasTimeStamp | hasSessionId | hasUserId |
     * ```
     */
    V4 = 4,
    /**
     * V3 说明：
     * ```
     * status            |   4byte
     * userId            |   可变长
     * sessionId         |   可变长
     * timestamp         |   8byte
     * descyptionType    |   1byte
     * secretKey         |   可变长
     * onlineClientInfo  |   可变长
     * ```
     */
    V3 = 3
}

/**
 * @todo 注释补全
 * @description
 * Header 处理
*/
declare class Header {
    readonly type: OperationType;
    private readonly _retain;
    qos: QOS;
    private readonly _dup;
    readonly syncMsg: boolean;
    constructor(type: OperationType, retain?: boolean, qos?: QOS, dup?: boolean);
    encode(): number;
}
/**
 * @description
 * 融云读取二进制数据
*/
declare class RongStreamReader {
    private _pool;
    private _position;
    private _poolLen;
    constructor(arr: Uint8Array);
    check(): boolean;
    /**
     * 读 2 位
     */
    read2Byte(): number;
    /**
     * 读 4 位
     */
    readInt(): number;
    /**
     * 读 8 位
     */
    readLong(): number;
    /**
     * 读 1 位
     */
    readByte(): number;
    /**
     * 获取数据
     */
    readUTF(): string;
    /**
     * 读剩余的所有值
     */
    readAll(): Uint8Array;
}
/**
 * @description
 * 融云写入二进制数据
*/
declare class RongStreamWriter {
    private _pool;
    private _position;
    private _writen;
    /**
     * 写入缓存区, writen 值往后移
     */
    write(byte: number): number;
    writeArr(byte: Array<number>): number[];
    writeUTF(str: string): void;
    getBytesArray(): Array<number>;
}

/**
 * @description
 * 与 Server 交互的信令封装
*/
/**
 * @description
 * 读数据处理基类
*/
declare class BaseReader {
    readonly header: Header;
    protected _name: string | null;
    lengthSize: number;
    messageId: number;
    timestamp: number;
    syncMsg: boolean;
    identifier: string;
    constructor(header: Header);
    getIdentifier(): string | number;
    read(stream: RongStreamReader, length: number, protocolVer: ConnAckProtocolVer): void;
    readMessage(stream: RongStreamReader, length?: number, protocolVer?: ConnAckProtocolVer): {
        stream: RongStreamReader;
        length: number | undefined;
    };
}
/**
 * @description
 * 写数据处理基类
 */
declare abstract class BaseWriter {
    private _header;
    lengthSize: number;
    data: any;
    messageId: number;
    topic: string;
    targetId: string;
    identifier: string;
    constructor(headerType: OperationType);
    getIdentifier(): string | number;
    write(stream: RongStreamWriter): void;
    abstract writeMessage(stream: RongStreamWriter): void;
    setHeaderQos(qos: number): void;
    getHeaderFlag(): number;
    getLengthSize(): number;
    getBufferData(): Int8Array;
    getCometData(): string;
}
declare class RetryableReader extends BaseReader {
    messageId: number;
    readMessage(stream: RongStreamReader, length: number): {
        stream: RongStreamReader;
        length: number;
    };
}
declare class RetryableWriter extends BaseWriter {
    messageId: number;
    writeMessage(stream: RongStreamWriter): void;
}
declare class PublishReader extends RetryableReader {
    _name: string;
    topic: string;
    data: any;
    targetId: string;
    date: any;
    syncMsg: boolean;
    identifier: string;
    readMessage(stream: RongStreamReader, length: number): {
        stream: RongStreamReader;
        length: number;
    };
}
/**
 * @description
 * 发消息使用
 */
declare class PublishWriter extends RetryableWriter {
    _name: string;
    topic: string;
    data: any;
    targetId: string;
    date: any;
    syncMsg: boolean;
    identifier: string;
    constructor(topic: string, data: any, targetId: string);
    writeMessage(stream: RongStreamWriter): void;
}
/**
 * @description
 * 发消息, Server 给的 Ack 回执
 */
declare class PubAckReader extends RetryableReader {
    _name: string;
    status: number;
    date: number;
    data: any;
    millisecond: number;
    messageUId: string;
    timestamp: number;
    identifier: string;
    topic: string;
    targetId: string;
    readMessage(stream: RongStreamReader, length: number): {
        stream: RongStreamReader;
        length: number;
    };
}
/**
 * @description
 * Web 主动查询
 */
declare class QueryWriter extends RetryableWriter {
    name: string;
    topic: string;
    data: any;
    targetId: string;
    identifier: string;
    constructor(topic: string, data: any, targetId: string);
    writeMessage(stream: RongStreamWriter): void;
}

interface IConversationOption {
    type: ConversationType;
    targetId: string;
    channelId?: string;
}
interface IChrmKVEntry {
    key: string;
    value?: string;
    isSendNotification?: boolean;
    notificationExtra?: string;
    isOverwrite?: boolean;
    isAutoDelete?: boolean;
    timestamp?: number;
    userId?: string;
    type?: number;
    isDeleted?: boolean;
}
interface IChrmKVEntries {
    entries: {
        key: string;
        value?: string;
    }[];
    notificationExtra?: string;
    isOverwrite?: boolean;
    isAutoDelete?: boolean;
    timestamp?: number;
    userId?: string;
    type?: number;
    isDeleted?: boolean;
}
interface IServerConversationStatus {
    conversationType: number;
    targetId: string;
    updatedTime?: number;
    notificationStatus?: number;
    isTop?: boolean;
    type?: number;
    tags?: IConversationTag[];
}
interface IUserSettingItem {
    targetId: number;
    type: number;
    key: string;
    value: any;
    version: number;
    status: number;
    tags: IConversationTag[];
}
interface IServerUserSetting {
    settings: {
        [key: string]: IUserSettingItem;
    };
    version: number;
}
interface ISyncMsgArgs {
    inboxTime: number;
    sendboxTime: number;
}
interface IGetMsgOption {
    timestamp?: number;
    count?: number;
    order?: number;
}
interface IGetConversationListOption {
    type?: number;
    count?: number;
    startTime?: number;
    order?: 0 | 1;
}
interface IClearMsgOption {
    timestamp?: number;
}
interface IServerRTCRoomEntry {
    key: string;
    value: string;
    status: number;
    timestamp: number;
    uid: string;
}

/**
 *  聊天室 kv 存储操作类型. 对方操作, 己方收到消息(RC:chrmKVNotiMsg)中会带入此值. 根据此值判断是删除还是更新
*/
declare enum ChatroomEntryType {
    UPDATE = 1,
    DELETE = 2
}

interface IGooglePushConfig {
    /**
     * 分组ID
     */
    collapseKey?: string;
    /**
     *
     */
    imageUrl?: string;
    /**
     *优先级
     */
    priority?: 'high' | 'normal';
}
interface IiOSPushConfig {
    /**
     * iOS 用于通知分组的 id
     */
    threadId?: string;
    /**
     * iOS 用于通知覆盖的 id
     */
    apnsCollapseId?: string;
    /**
     * iOS 分类，如果不设置后台默认取消息类型字符串，如RC:TxtMsg
     */
    category?: string;
    /**
     * 和 category 对应
     */
    richMediaUri?: string;
}
interface IAndroidPushConfig {
    /**
     * Android 的通知 id
     */
    notificationId?: string;
    /**
     * 小米的 channelId
     */
    channelIdMi?: string;
    /**
     * 华为的 channelId
     */
    channelIdHW?: string;
    /**
     * OPPO 的 channelId
     */
    channelIdOPPO?: string;
    /**
     * vivo 的类型
     */
    typeVivo?: string;
    /**
    * google FCM 的推送配置
    */
    googleConfig?: IGooglePushConfig;
}
interface IPushConfig {
    /**
     * 推送标题
     * 如果没有设置，会使用下面的默认标题显示规则
     * 默认标题显示规则：
     * 内置消息：单聊通知标题显示为发送者名称，群聊通知标题显示为群名称。
     * 自定义消息：默认不显示标题。
     */
    pushTitle: string;
    /**
     * 推送内容
     * 优先使用 IPushConfig.pushContent, 如果没有，则使用发送消息的 pushContent 参数
     */
    pushContent: string;
    /**
     * 远程推送附加信息
     * 优先使用 IPushConfig.pushData, 如果没有，则使用发送消息的 pushContent 参数
     */
    pushData: string;
    /**
     * iOSConfig
     */
    iOSConfig?: IiOSPushConfig;
    /**
     * androidConfig
     */
    androidConfig?: IAndroidPushConfig;
    /**
     * 是否显示推送标题. 仅针对 iOS 平台有效
     */
    disablePushTitle: boolean;
    /**
     * 是否强制推送
     */
    forceShowDetailContent: boolean;
    /**
     * 推送模板id
    */
    templateId: string;
}

interface IUserProfile {
    /**
      * 用户 ID
      */
    id?: string;
    /**
     * 用户名
     */
    name?: string;
    /**
     * 用户头像地址
     */
    portraitUri?: string;
    /**
     * user info 中附加信息
     */
    extra?: string;
}
/**
 * 发送消息时的可选项信息
 */
interface ISendMsgOptions {
    /**
     * 消息类型，即消息结构的 ObjectName
     */
    messageType: string;
    /**
     * 消息内容
     */
    content: {
        /**
         * 消息内容 key-value，最终会进行 JSON 序列化后发送
         */
        [key: string]: any;
        /**
         * 消息可携带的用户数据
         */
        user?: IUserProfile;
        /**
         * 其他拓展信息
         */
        extra?: string;
    };
    /**
     * 是否存储
     * @description 只在发送未注册过的自定义消息时有效，否则使用注册时的配置
     */
    isPersited?: boolean;
    /**
     * 是否计数
     * @description 只在发送未注册过的自定义消息时有效，否则使用注册时的配置
     */
    isCounted?: boolean;
    /**
     * 是否是状态消息，一般为无需注册的自定义消息
     * @description
     * 1. 状态消息只有 pub，没有 ack 应答
     * 2. 状态消息默认不存储，不计数，`isPersited` 与 `isCounted` 配置将失效
     */
    isStatusMessage?: boolean;
    /**
     * 是否发送静默消息
     * @description
     * 当值为 `true` 时，服务器将不会发送 Push 信息，移动端也不会弹出本地通知提醒
     */
    disableNotification?: boolean;
    /**
     * Push 信息
     */
    pushContent?: string;
    /**
     * Push 通知携带的附加信息
     */
    pushData?: string;
    /**
     * 是否为 @ 消息，只当 conversationType 值为 `ConversationType.GROUP` 时有效
     */
    isMentioned?: boolean;
    /**
     * `@` 消息类型
     * @description `1: @ 所有人 2: @ 指定用户`
     */
    mentionedType?: 1 | 2;
    /**
     * 被 @ 的用户 Id 列表，当 `mentionedType` 值为 `1` 时，该值可为空
     */
    mentionedUserIdList?: string[];
    /**
     * 用于发送群定向消息，只当 conversationType 值为 `ConversationType.GROUP` 时有效
     */
    directionalUserIdList?: string[];
    /**
     * 当对方为 iOS 设备且未在线时，其将收到 Voip Push. 此配置对 Android 无影响
     */
    isVoipPush?: boolean;
    /**
     * 消息是否支持拓展内容
     */
    canIncludeExpansion?: boolean;
    /**
     * 消息拓展内容数据
     */
    expansion?: {
        [key: string]: string;
    };
    /**
     * 黑/白名单
     * @todo 功能未知，需确认
     */
    isFilerWhiteBlacklist?: boolean;
    /**
     * 移动端推送配置
    */
    pushConfig?: IPushConfig;
    /**
     * 会话业务标识
     * @description
     * 20 个字符长度限制
    */
    channelId?: string;
}

/**
 * TODO: 确定对外暴露的必要性
 * @deprecated
 */
declare const DelayTimer: {
    _delayTime: number;
    /**
     * 方法并未引用，getTimer 实际返回值始终为 Date.now()
     * @deprecated
     */
    setTime: (time: number) => void;
    getTime: () => number;
};

/**
 * IM  错误码范围段
 * 2 开头为 IM Server 返回错误码
 * 3 开头： 30000 到 33xxx 为协议栈错误码，34001 ~ 34999 为移动端自定错误码
 *   备注：iOS 与 Android 错误码一致。Web 与移动端一致的错误码，也用此片段，比如 34008 （消息不支持扩展）
 * 35001 ~ 39999 为 Web 端错误码 备注：由于 Web IM 历史版本 35xxx 36xxx 37xxx 38xxx 39xxxx 都占用过，所以错误码段范围较大
 */
declare enum ErrorCode {
    /** 超时 */
    TIMEOUT = -1,
    /**
     * 未知原因失败。
     */
    UNKNOWN = -2,
    /** 参数错误 */
    PARAMETER_ERROR = -3,
    /** 未实现的方法定义，在应用层调用 callExtra 传入无法识别的方法名时抛出 */
    EXTRA_METHOD_UNDEFINED = -4,
    /** 主进程内方法错误 */
    MAIN_PROCESS_ERROR = -5,
    /**
     * 成功
     */
    SUCCESS = 0,
    RC_MSG_UNAUTHORIZED = 20406,
    /**
     * 群组 Id 无效
     */
    RC_DISCUSSION_GROUP_ID_INVALID = 20407,
    /**
     * 发送频率过快
     */
    SEND_FREQUENCY_TOO_FAST = 20604,
    /**
     * 不在讨论组。
     */
    NOT_IN_DISCUSSION = 21406,
    /**
     * 群组被禁言
     */
    FORBIDDEN_IN_GROUP = 22408,
    RECALL_MESSAGE = 25101,
    /**
     * 不在群组。
     */
    NOT_IN_GROUP = 22406,
    /**
     * 不在聊天室。
     */
    NOT_IN_CHATROOM = 23406,
    /**
     *聊天室被禁言
     */
    FORBIDDEN_IN_CHATROOM = 23408,
    /**
     * 聊天室中成员被踢出
     */
    RC_CHATROOM_USER_KICKED = 23409,
    /**
     * 聊天室不存在
     */
    RC_CHATROOM_NOT_EXIST = 23410,
    /**
     * 聊天室成员已满
     */
    RC_CHATROOM_IS_FULL = 23411,
    /**
     * 获取聊天室信息参数无效
     */
    RC_CHATROOM_PATAMETER_INVALID = 23412,
    /**
     * 聊天室异常
     */
    CHATROOM_GET_HISTORYMSG_ERROR = 23413,
    /**
     * 没有打开聊天室消息存储
     */
    CHATROOM_NOT_OPEN_HISTORYMSG_STORE = 23414,
    /**
     * 聊天室 KV 设置超出最大值(已满, 默认最多设置 100 个)
     */
    CHATROOM_KV_EXCEED = 23423,
    /**
     * 聊天室 KV 设置失败(kv 已存在, 需覆盖设置)
     */
    CHATROOM_KV_OVERWRITE_INVALID = 23424,
    /**
     * 聊天室 KV 存储功能没有开通
     */
    CHATROOM_KV_STORE_NOT_OPEN = 23426,
    /**
     * 聊天室Key不存在
     */
    CHATROOM_KEY_NOT_EXIST = 23427,
    /**
     * 敏感词屏蔽
     */
    SENSITIVE_SHIELD = 21501,
    SENSITIVE_REPLACE = 21502,
    /**
     * 加入讨论失败
     */
    JOIN_IN_DISCUSSION = 21407,
    /**
     * 创建讨论组失败
     */
    CREATE_DISCUSSION = 21408,
    /**
     * 设置讨论组邀请状态失败
     */
    INVITE_DICUSSION = 21409,
    /**
     *获取用户失败
     */
    GET_USERINFO_ERROR = 23407,
    /**
     * 在黑名单中。
     */
    REJECTED_BY_BLACKLIST = 405,
    /**
     * 通信过程中，当前 Socket 不存在。
     */
    RC_NET_CHANNEL_INVALID = 30001,
    /**
     * Socket 连接不可用。
     */
    RC_NET_UNAVAILABLE = 30002,
    /**
     * 通信超时。
     */
    RC_MSG_RESP_TIMEOUT = 30003,
    /**
     * 导航操作时，Http 请求失败。
     */
    RC_HTTP_SEND_FAIL = 30004,
    /**
     * HTTP 请求失败。
     */
    RC_HTTP_REQ_TIMEOUT = 30005,
    /**
     * HTTP 接收失败。
     */
    RC_HTTP_RECV_FAIL = 30006,
    /**
     * 导航操作的 HTTP 请求，返回不是200。
     */
    RC_NAVI_RESOURCE_ERROR = 30007,
    /**
     * 导航数据解析后，其中不存在有效数据。
     */
    RC_NODE_NOT_FOUND = 30008,
    /**
     * 导航数据解析后，其中不存在有效 IP 地址。
     */
    RC_DOMAIN_NOT_RESOLVE = 30009,
    /**
     * 创建 Socket 失败。
     */
    RC_SOCKET_NOT_CREATED = 30010,
    /**
     * Socket 被断开。
     */
    RC_SOCKET_DISCONNECTED = 30011,
    /**
     * PING 操作失败。
     */
    RC_PING_SEND_FAIL = 30012,
    /**
     * PING 超时。
     */
    RC_PONG_RECV_FAIL = 30013,
    /**
     * 消息发送失败。
     */
    RC_MSG_SEND_FAIL = 30014,
    /**
     * JSON 后的消息体超限, 目前最大 128kb
     */
    RC_MSG_CONTENT_EXCEED_LIMIT = 30016,
    /**
     * 做 connect 连接时，收到的 ACK 超时。
     */
    RC_CONN_ACK_TIMEOUT = 31000,
    /**
     * 参数错误。
     */
    RC_CONN_PROTO_VERSION_ERROR = 31001,
    /**
     * 参数错误，App Id 错误。
     */
    RC_CONN_ID_REJECT = 31002,
    /**
     * 服务器不可用。
     */
    RC_CONN_SERVER_UNAVAILABLE = 31003,
    /**
     * Token 错误。
     */
    RC_CONN_USER_OR_PASSWD_ERROR = 31004,
    /**
     * websocket 鉴权失败，通常为连接后未及时发送 Ping 或接收到 Pong
     */
    RC_CONN_NOT_AUTHRORIZED = 31005,
    /**
     * 重定向，地址错误。
     */
    RC_CONN_REDIRECTED = 31006,
    /**
     * NAME 与后台注册信息不一致。
     */
    RC_CONN_PACKAGE_NAME_INVALID = 31007,
    /**
     * APP 被屏蔽、删除或不存在。
     */
    RC_CONN_APP_BLOCKED_OR_DELETED = 31008,
    /**
     * 用户被屏蔽。
     */
    RC_CONN_USER_BLOCKED = 31009,
    /**
     * Disconnect，由服务器返回，比如用户互踢。
     */
    RC_DISCONN_KICK = 31010,
    /**
     * Disconnect，由服务器返回，比如用户互踢。
     */
    RC_DISCONN_EXCEPTION = 31011,
    /**
     * app 验证Token 验证不通过。所有内部超时，访问失败,返回给客户端sdk都是验证不通过，由服务端日志去看具体是那种失败。
     */
    RC_APP_AUTH_NOT_PASS = 31026,
    /**
     * One Time Password 已经被使用过
     */
    RC_OTP_USED = 31027,
    /**
     * token平台验证失败
     */
    RC_PLATFORM_ERROR = 31028,
    /**
     * 协议层内部错误。query，上传下载过程中数据错误。
     */
    RC_QUERY_ACK_NO_DATA = 32001,
    /**
     * 协议层内部错误。
     */
    RC_MSG_DATA_INCOMPLETE = 32002,
    /**
     * 未调用 init 初始化函数。
     */
    BIZ_ERROR_CLIENT_NOT_INIT = 33001,
    /**
     * 数据库初始化失败。
     */
    BIZ_ERROR_DATABASE_ERROR = 33002,
    /**
     * 传入参数无效。
     */
    BIZ_ERROR_INVALID_PARAMETER = 33003,
    /**
     * 通道无效。
     */
    BIZ_ERROR_NO_CHANNEL = 33004,
    /**
     * 重新连接成功。
     */
    BIZ_ERROR_RECONNECT_SUCCESS = 33005,
    /**
     * 连接中，再调用 connect 被拒绝。
     */
    BIZ_ERROR_CONNECTING = 33006,
    /**
     * 消息漫游服务未开通
     */
    MSG_ROAMING_SERVICE_UNAVAILABLE = 33007,
    MSG_INSERT_ERROR = 33008,
    MSG_DEL_ERROR = 33009,
    /**
     * 标签不存在
     */
    TAG_NOT_EXIST = 33101,
    /**
     * 会话中不存在此标签
     */
    NO_TAG_IN_CONVER = 33102,
    /**
     * 删除会话失败
     */
    CONVER_REMOVE_ERROR = 34001,
    /**
     *拉取历史消息
     */
    CONVER_GETLIST_ERROR = 34002,
    /**
     * 会话指定异常
     */
    CONVER_SETOP_ERROR = 34003,
    /**
     * 获取会话未读消息总数失败
     */
    CONVER_TOTAL_UNREAD_ERROR = 34004,
    /**
     * 获取指定会话类型未读消息数异常
     */
    CONVER_TYPE_UNREAD_ERROR = 34005,
    /**
     * 获取指定用户ID&会话类型未读消息数异常
     */
    CONVER_ID_TYPE_UNREAD_ERROR = 34006,
    CONVER_CLEAR_ERROR = 34007,
    /**
     * 扩展存储 key value 超出限制 (错误码与移动端对齐)
    */
    EXPANSION_LIMIT_EXCEET = 34010,
    /**
     * 消息不支持扩展 (错误码与移动端对齐)
    */
    MESSAGE_KV_NOT_SUPPORT = 34008,
    CLEAR_HIS_TIME_ERROR = 34011,
    /**
     * 会话数量超出上限
     */
    CONVER_OUT_LIMIT_ERROR = 34013,
    CONVER_GET_ERROR = 34009,
    /**
     * 群组信息异常
     */
    GROUP_SYNC_ERROR = 35001,
    /**
     * 匹配群信息异常
     */
    GROUP_MATCH_ERROR = 35002,
    /**
     * 已读回执方法调用错误（导航开关为1时调用新接口，否则调用sendMessage）
     */
    READ_RECEIPT_ERROR = 35003,
    /**
     * 公有云包不允许连接私有云环境
     */
    PACKAGE_ENVIRONMENT_ERROR = 35006,
    /**
     * 已连接或者内部重连中，不允许调用重连，需先调用 disconnect 方法
     */
    CAN_NOT_RECONNECT = 35007,
    /**
     * 不支持的平台类型，一般小程序或 PC 未开通
     */
    SERVER_UNAVAILABLE = 35008,
    /**
     * Web 端设置安全域名后，连接端域名不在安全域名范围内
     */
    HOSTNAME_ERROR = 35009,
    /**
     * 开启`禁止把已在线客户端踢下线`开关后，该错误码标识已有同类型端在线，禁止链接
     */
    HAS_OHTER_SAME_CLIENT_ON_LINE = 35010,
    /**
     * 加入聊天室Id为空
     */
    CHATROOM_ID_ISNULL = 36001,
    /**
     * 加入聊天室失败
     */
    CHARTOOM_JOIN_ERROR = 36002,
    /**
     * 拉取聊天室历史消息失败
     */
    CHATROOM_HISMESSAGE_ERROR = 36003,
    /**
     * 聊天室 kv 未找到
     */
    CHATROOM_KV_NOT_FOUND = 36004,
    /**
     * 加入黑名单异常
     */
    BLACK_ADD_ERROR = 37001,
    /**
     * 获得指定人员再黑名单中的状态异常
     */
    BLACK_GETSTATUS_ERROR = 37002,
    /**
     * 移除黑名单异常
     */
    BLACK_REMOVE_ERROR = 37003,
    /**
     * 获取草稿失败
     */
    DRAF_GET_ERROR = 38001,
    /**
     * 保存草稿失败
     */
    DRAF_SAVE_ERROR = 38002,
    /**
     * 删除草稿失败
     */
    DRAF_REMOVE_ERROR = 38003,
    /**
     * 关注公众号失败
     */
    SUBSCRIBE_ERROR = 39001,
    /**
     * 方法未支持
     */
    NOT_SUPPORT = 39002,
    /**
     * 关注公众号失败
     */
    QNTKN_FILETYPE_ERROR = 41001,
    /**
     * 获取七牛token失败
     */
    QNTKN_GET_ERROR = 41002,
    /**
     * cookie被禁用
     */
    COOKIE_ENABLE = 51001,
    GET_MESSAGE_BY_ID_ERROR = 61001,
    HAVNODEVICEID = 24001,
    DEVICEIDISHAVE = 24002,
    FEILD = 24009,
    VOIPISNULL = 24013,
    NOENGINETYPE = 24010,
    NULLCHANNELNAME = 24011,
    VOIPDYANMICERROR = 24012,
    NOVOIP = 24014,
    INTERNALERRROR = 24015,
    VOIPCLOSE = 24016,
    CLOSE_BEFORE_OPEN = 51001,
    ALREADY_IN_USE = 51002,
    INVALID_CHANNEL_NAME = 51003,
    VIDEO_CONTAINER_IS_NULL = 51004,
    /**
     * 删除消息数组长度为 0 .
     */
    DELETE_MESSAGE_ID_IS_NULL = 61001,
    /**
     * 己方取消已发出的通话请求
     */
    CANCEL = 1,
    /**
     * 己方拒绝收到的通话请求
     */
    REJECT = 2,
    /**
     * 己方挂断
     */
    HANGUP = 3,
    /**
     * 己方忙碌
     */
    BUSYLINE = 4,
    /**
     * 己方未接听
     */
    NO_RESPONSE = 5,
    /**
     * 己方不支持当前引擎
     */
    ENGINE_UN_SUPPORTED = 6,
    /**
     * 己方网络出错
     */
    NETWORK_ERROR = 7,
    /**
     * 对方取消已发出的通话请求
     */
    REMOTE_CANCEL = 11,
    /**
     * 对方拒绝收到的通话请求
     */
    REMOTE_REJECT = 12,
    /**
     * 通话过程对方挂断
     */
    REMOTE_HANGUP = 13,
    /**
     * 对方忙碌
     */
    REMOTE_BUSYLINE = 14,
    /**
     * 对方未接听
     */
    REMOTE_NO_RESPONSE = 15,
    /**
     * 对方网络错误
     */
    REMOTE_ENGINE_UN_SUPPORTED = 16,
    /**
     * 对方网络错误
     */
    REMOTE_NETWORK_ERROR = 17,
    /**
     * VoIP 不可用
     */
    VOIP_NOT_AVALIABLE = 18,
    /**
     * 聊天室批量设置kv部分不成功
     */
    CHATROOM_KV_STORE_NOT_ALL_SUCCESS = 23428,
    /**
     * 聊天室设置批量kv，一次不能超过10个
     */
    CHATROOM_KV_STORE_OUT_LIMIT = 23429
}

/**
 * 音视频模式
 */
declare enum RTCMode {
    /**
     * 普通音视频模式
     */
    RTC = 0,
    /**
     * 直播模式
     */
    LIVE = 2
}
/**
 * 直播类型
 */
declare enum LiveType {
    /**
     * 音视频直播
     */
    AUDIO_AND_VIDEO = 0,
    /**
     * 音频直播
     */
    AUDIO = 1
}
declare enum LiveRole {
    /**
     * 主播身份
     */
    ANCHOR = 1,
    /**
     * 观众身份
     */
    AUDIENCE = 2
}
/**
 * CallLib 流程消息
 */
declare const CallLibMsgType: {
    'RC:VCAccept': string;
    'RC:VCRinging': string;
    'RC:VCSummary': string;
    'RC:VCHangup': string;
    'RC:VCInvite': string;
    'RC:VCModifyMedia': string;
    'RC:VCModifyMem': string;
};
declare enum RTCApiType {
    ROOM = 1,
    PERSON = 2
}
declare enum RTCIdentityChangeType {
    AnchorToViewer = 1,
    ViewerToAnchor = 2
}
/**
 * RTC 房间加入类型
 */
declare enum RTCJoinType {
    /**
     * 踢前一个设备
     */
    KICK = 0,
    /**
     * 当前加入拒绝
     */
    REFUSE = 1,
    /**
     * 两个设备共存
     */
    COEXIST = 2
}

declare enum MessageDirection {
    /**
     * 己方发送消息
     */
    SEND = 1,
    /**
     * 己方接收消息
     */
    RECEIVE = 2
}

/**
 * 序列化、反序列化数据通道
*/
declare class DataCodec {
    private _codec;
    private _connectType;
    constructor(connectType: 'websocket' | 'comet');
    /**
     * PB 数据 转为 rmtp 数据 反序列化 通用数据
     * 根据解析的 PBName 分配解码方法. 如果没有单独的解码方法定义. 直接返回 pb 解析后的结果
    */
    decodeByPBName(data: any, pbName: string, option?: any): any;
    private _readBytes;
    /**
     * ====== 以下为 rmtp 数据 反序列化为 可用数据 ======
     */
    private _formatBytes;
    /**
     * 格式化多端同步消息
    */
    private _formatSyncMessages;
    /**
     * 格式化接收消息
    */
    private _formatReceivedMessage;
    /**
     * 格式化发送消息
    */
    private _formatSentMessage;
    /**
     * 格式化历史消息
    */
    private _formatHistoryMessages;
    /**
     * 格式化会话列表
    */
    private _formatConversationList;
    /**
     * 格式化用户设置
    */
    private _formatSetUserSettingOutput;
    /**
     * 格式化聊天室信息
    */
    private _formatChatRoomInfos;
    /**
     * 格式化 聊天室 KV 列表
    */
    private _formatChatRoomKVList;
    /**
     * 格式化 用户设置
    */
    private _formatUserSetting;
    /**
     * 格式化 会话状态 置顶、免打扰）
    */
    private _formatConversationStatus;
    /**
     * 格式化 RTC 用户列表
    */
    private _formatRTCUserList;
    /**
      * 格式化 RTC 数据
    */
    private _formatRTCData;
    /**
      * 格式化 RTC 房间信息
    */
    private _formatRTCRoomInfo;
    /**
      * 格式化 获取已读列表
    */
    private _formatGrpReadReceiptQryResp;
    /**
     * 格式化用户配置通知
     */
    private _formatUserSettingNotification;
    /**
     * 格式化 RTC 用户加入房间后通知拉取的数据（房间内主播全量列表、房间全量资源）
     */
    private _formatRTCRoomKVList;
    /**
     * 格式化观众加房间后返回数据
     */
    private _formatRTCAuidenceJoinRoomData;
    /**
     * 格式化加入 RTC 房间的用户信息
     */
    private _formatRTCJoinedUserInfo;
    /**
     * ===== 以下为通用数据 序列化为 PB 数据 =====
     * Engine Index 调用处理数据
    */
    /**
     * ? 待补全注释
    */
    encodeServerConfParams(): any[];
    /**
     * 上行消息基础配置
    */
    private _getUpMsgModule;
    /**
     * 序列化上行消息
    */
    encodeUpMsg(conversation: IConversationOption, option: ISendMsgOptions): any[];
    /**
     * 序列化拉取多端消息
    */
    encodeSyncMsg(syncMsgArgs: ISyncMsgArgs): any[];
    /**
     * 序列化拉取聊天室消息
    */
    encodeChrmSyncMsg(time: number, count: number): any[];
    /**
     * 序列化历史消息
    */
    encodeGetHistoryMsg(targetId: string, option: IGetMsgOption): any[];
    /**
     * 序列化会话列表
    */
    encodeGetConversationList(option: IGetConversationListOption): any[];
    /**
     * 旧会话列表. 获取、删除都调用此方法
    */
    encodeOldConversationList(option: IGetConversationListOption): any[];
    /**
     * 旧会话列表删除
    */
    encodeRemoveConversationList(conversationList: IConversationOption[]): any[];
    /**
     * 批量删除消息通过消息 ID
    */
    encodeDeleteMessages(conversationType: ConversationType, targetId: string, list: {
        messageUId: string;
        sentTime: number;
        messageDirection: MessageDirection;
    }[]): any[];
    /**
     * 批量删除消息通过时间
    */
    encodeClearMessages(targetId: string, timestamp: number): any[];
    /**
     * 未读数清除
    */
    encodeClearUnreadCount(conversation: IConversationOption, option: IClearMsgOption): any[];
    /**
     * 加入退出聊天室
    */
    encodeJoinOrQuitChatRoom(): any[];
    /**
     * 获取聊天室信息
     * @param count 获取人数
     * @param order 排序方式
    */
    encodeGetChatRoomInfo(count: number, order: number): any[];
    /**
     * 上传文件认证信息获取
    */
    encodeGetFileToken(fileType: number, fileName: string, httpMethod?: string, queryString?: string): any;
    /**
      * 获取七牛上传url
    */
    encodeGetFileUrl(inputPBName: string, fileType: number, fileName?: string, originName?: string): any;
    /**
      * 聊天室 KV 存储
    */
    encodeModifyChatRoomKV(chrmId: string, entry: IChrmKVEntry, currentUserId: string): any;
    encodeModifyChatRoomKVS(chrmId: string, entryOptions: IChrmKVEntries, currentUserId: string): any;
    /**
      * KV 存储拉取
    */
    encodePullChatRoomKV(time: number): any;
    /**
      * 用户实时配置更新
    */
    encodePullUserSetting(version: number): any;
    /**
      * 获取会话状态 (置顶、免打扰)
    */
    encodeGetConversationStatus(time: number): any;
    /**
      * 设置会话状态 (置顶、免打扰)
    */
    encodeSetConversationStatus(statusList: Array<IServerConversationStatus>): any;
    /**
     * 序列化发送群组已读回执
     */
    encodeReadReceipt(messageUIds: string[], channelId?: string): any;
    /**
     * 序列化创建tag消息
     */
    encodeCreateTag(tags: Array<ITagParam>, version: number): any;
    /**
     * 序列化获取群组消息已读列表
     */
    encodeMessageReader(messageUId: string, channelId?: string): any;
    /**
     * 序列化删除tag消息
     */
    encodeRemoveTag(tagIds: Array<string>, version: number): any;
    /**
     * 解除会话标签关系
     */
    encodeDisConversationTag(tagIds: Array<string>): any;
    /**
     * 序列化更新会话标签
     */
    encodeUpdateConversationTag(tags: IConversationTag[], conversations: IConversationOption[]): any;
    /**
     * 序列号上报SDK信息
     */
    encodeReportSDKInfo(info: string): any;
    /**
     * ============ 以下为 RTC 相关 ============
     */
    /**
     * 加入 RTC 房间
     */
    encodeJoinRTCRoom(mode: RTCMode, broadcastType?: number, joinType?: RTCJoinType): any[];
    /**
     * 退出 RTC 房间
     */
    encodeQuitRTCRoom(): any[];
    /**
     * 用户属性设置，及消息通知
     */
    encodeSetRTCData(key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): any;
    /**
     * 全量 URI
     */
    encodeUserSetRTCData(message: any, valueInfo: string, objectName: string, mcuValInfo: string): any;
    encodeUserSetRTCCDNUris(objectName: string, CDNUris: string): any;
    /**
     * 用户属性获取
    */
    encodeGetRTCData(keys: Array<string>, isInner: boolean, apiType: RTCApiType): any;
    /**
     * 用户属性删除
    */
    encodeRemoveRTCData(keys: Array<string>, isInner: boolean, apiType: RTCApiType, message: any): any;
    /**
     * 待完善注释
     * @deprecated
    */
    encodeSetRTCOutData(data: any, type: number, message: any): any;
    /**
     * 待完善注释
     * @deprecated
    */
    ecnodeGetRTCOutData(userIds: string[]): any;
    /**
     * rtc 北极星数据上传
     */
    encodeSetRTCState(report: string): any;
    /**
     * 获取房间用户资源
    */
    encodeGetRTCRoomInfo(): any;
    /**
     * 设置用户资源
    */
    encodeSetRTCUserInfo(key: string, value: string): any;
    /**
     * 删除用户及资源
    */
    encodeRemoveRTCUserInfo(keys: string[]): any;
    /**
     * RTC 直播房间身份切换
    */
    encodeIdentityChangeInfo(changeType: RTCIdentityChangeType, broadcastType?: number, needSyncChrm?: boolean): any;
    /**
     * RTC 直播观众拉取房间内 KV
    */
    encodePullRTCRoomKV(roomId: string, timestamp: number): any;
    /**
     * RTC 查询在房间内用户的信息
     */
    encodeQueryUserJoinedInfo(userId: string): any;
}

/**
 * 连接状态
 */
declare enum ConnectionStatus {
    /**
     * 连接成功。
     */
    CONNECTED = 0,
    /**
     * 连接中。
     */
    CONNECTING = 1,
    /**
     * 正常断开连接。
     */
    DISCONNECTED = 2,
    /**
     * 网络不可用。
     */
    NETWORK_UNAVAILABLE = 3,
    /**
     * 连接关闭。
     */
    CONNECTION_CLOSED = 4,
    /**
     * 用户账户在其他设备登录，本机会被踢掉线。
     */
    KICKED_OFFLINE_BY_OTHER_CLIENT = 6,
    /**
     * websocket 连接失败
     */
    WEBSOCKET_UNAVAILABLE = 7,
    /**
     * websocket 报错
     */
    WEBSOCKET_ERROR = 8,
    /**
     * 用户被封禁
     */
    BLOCKED = 9,
    /**
     * 域名错误
     */
    DOMAIN_INCORRECT = 12,
    /**
     * 服务器主动断开
     */
    DISCONNECT_BY_SERVER = 13,
    /**
     * 重定向
     */
    REDIRECT = 14,
    /**
     * appkey 不正确
     */
    APPKEY_IS_FAKE = 20,
    /**
     * 互踢次数过多（`count > 5`），此时可能出现：在其它他设备登陆有 reconnect 逻辑
     */
    ULTRALIMIT = 1101,
    /**
     * 开始请求导航
     */
    REQUEST_NAVI = 201,
    /**
     * 请求导航结束
     */
    RESPONSE_NAVI = 202,
    /**
     *  请求导航失败
     */
    RESPONSE_NAVI_ERROR = 203,
    /**
     *  请求导航超时
     */
    RESPONSE_NAVI_TIMEOUT = 204
}

interface IAsyncRes<T = any> {
    /**
     * Promise 执行结果
     */
    code: ErrorCode;
    /**
     * 结果数据
     */
    data?: T;
}
/**
 * 异步任务结果定义
 * @description
 * 通过 `Promise.resolve` 来处理预期内的异常，进而通过 Uncatch Promise Error 暴露预期外的异常
 */
declare type IPromiseResult<T> = Promise<IAsyncRes<T>>;

interface IDataChannelWatcher {
    /**
     * 连接状态变更通知
     */
    status: (status: ConnectionStatus) => void;
    /**
     * 业务信令通知
     * @params signal
     * @params ack 当接收到的数据为多端同步消息时，ack 值为 PubAck，否则为 undefined
     */
    signal: (signal: PublishReader, ack?: PubAckReader) => void;
}
/**
 * 数据通道接口，为 long-polling 与 websocket 提供公共抽象
 */
declare abstract class ADataChannel {
    protected _watcher: IDataChannelWatcher;
    /**
     * 通道所需的数据编解码器
     */
    readonly codec: DataCodec;
    connectedTime: number;
    userId: string;
    sendConnectTime: number;
    constructor(type: 'websocket' | 'comet', _watcher: IDataChannelWatcher);
    /**
     * 建立连接，连接成功则返回 Websocket 实例，否则返回连接错误码
     * @param appkey
     * @param token
     * @param hosts 服务器地址，不包含协议头，`hostname:port`
     * @param protocol 请求导航数据时使用的网络协议, /ping 与 websocket 需要继续遵循该协议
     * @param apiVersion - apiVersion 需符合 `/\d+(\.\d+){2}/` 规则，对于预发布版本号如 `3.1.0-alpha.1` 需认定为 `3.1.0`
     */
    abstract connect(appkey: string, token: string, host: string[], protocol: 'http' | 'https', apiVersion: string, protocolVer: ConnAckProtocolVer): Promise<ErrorCode>;
    /**
     * 只发送数据，无需响应
     */
    abstract sendOnly(writer: BaseWriter): void;
    /**
     *
     * @param writer
     * @param pbName 响应数据的 PB 定义
     * @param timeout 超时配置，单位 ms
     */
    abstract send<T>(writer: QueryWriter | PublishWriter, pbName?: string, option?: any, timeout?: number): IPromiseResult<T>;
    /**
     * 关闭数据通道，同时清空监听
     */
    abstract close(): void;
}

declare enum HttpMethod {
    GET = "GET",
    POST = "POST"
}
interface IRequest {
    url: string;
    /**
     * @default `HttpMethod.GET`
     */
    method?: HttpMethod | 'GET' | 'POST';
    /**
     * 查询数据
     */
    query?: {
        [key: string]: string | number | null;
    };
    /**
     * Request Header 信息
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Request Body 数据
     */
    body?: Object | string;
    /**
     * 超时设置
     * @default 10 * 1000 毫秒
     */
    timeout?: number;
}
interface IStorage {
    setItem(key: string, value: string): void;
    getItem(key: string): string | null;
    removeItem(key: string): void;
    clear(): void;
}
interface IResponse {
    status: number;
    data?: string;
}
interface IWebSocket {
    /**
     * 监听连接建立事件，此时 WebSocket 实例已准备好收发数据
     * @param callback
     */
    onOpen(callback: () => void): void;
    /**
     * 监听连接关闭事件
     * @param callback
     */
    onClose(callback: (code?: number, reason?: string) => void): void;
    /**
     * 监听接收服务器消息事件
     * @param callback
     */
    onMessage(callback: (data: string | ArrayBuffer) => void): void;
    /**
     * 监听链接错误事件
     * @param callback
     */
    onError(callback: (error: unknown) => void): void;
    /**
     * 向服务器发送数据
     * @param data
     */
    send(data: ArrayBuffer | string): void;
    /**
     * 关闭连接
     * @param code
     * @param reason
     */
    close(code?: number, reason?: string): void;
}
/**
 * 平台运行时抽象
 */
interface IRuntime {
    /**
     * 平台标识
     */
    tag: string;
    /**
     * 发送 http 请求
     * @param options
     */
    httpReq(options: IRequest): Promise<IResponse>;
    /**
     * 检测是否支持长连接
     */
    isSupportSocket(): boolean;
    /**
     * 是否使用导航
     */
    useNavi: boolean;
    /**
     * websocket 地址上附加的平台字段
     */
    connectPlatform: string;
    /**
     * websocket 地址上 apiVer 字段，代表代码是否来源于 uniapp
     */
    isFromUniapp: boolean;
    /**
     * 创建长连接实例
     */
    createWebSocket?(url: string, protocols?: string[]): IWebSocket;
    /**
     * 创建数据通道
     */
    createDataChannel(watcher: IDataChannelWatcher, connectType?: 'websocket' | 'comet'): ADataChannel;
    /**
     * 存储模块
     */
    localStorage: IStorage;
    /**
     * 在某些非浏览器平台，其等同于 localStorage
     */
    sessionStorage: IStorage;
}

/**
 * @todo 迁移中的 DataCodec 模块导致数据通道不够独立，与 xhr-polling 通信可能会有耦合，后续需解耦
 * @description
 * 1. 基于 WebSocket 协议建立数据通道，实现数据收发
 * 2. 基于 Protobuf 进行数据编解码
 */
declare class WebSocketChannel extends ADataChannel {
    private _runtime;
    private _socket;
    private _pingResolve?;
    /**
     * 本端发送消息时等待接收 PubAck 的 Promise.resolve 函数
     */
    private _messageIds;
    /**
     * 接收多端同步消息时，等待 PubAck 的 Promise.resolve 函数
     */
    private _syncMessageIds;
    constructor(_runtime: IRuntime, watcher: IDataChannelWatcher);
    /**
     * 建立 websocket 连接
     * @param appkey
     * @param token
     * @param hosts
     * @param protocol
     * @param apiVersion - apiVersion 需符合 `/\d+(\.\d+){2}/` 规则
     */
    connect(appkey: string, token: string, hosts: string[], protocol: 'http' | 'https', apiVersion: string, protocolVer: ConnAckProtocolVer): Promise<ErrorCode>;
    /**
     * 当前累计心跳超时次数
     */
    private _failedCount;
    /**
     * 允许连续 PING 超时次数，次数内不主动关闭连接
     */
    private readonly ALLOW_FAILED_TIMES;
    /**
     * ping定时器
     */
    private _timer;
    private _checkAlive;
    private _onReceiveSignal;
    sendOnly(writer: BaseWriter): void;
    /**
     * 有效值 0 - 65535，超出 65535 位数超长溢出
     */
    private _idCount;
    private _generateMessageId;
    send(writer: QueryWriter | PublishWriter, respPBName?: string, option?: any, timeout?: number): Promise<IAsyncRes>;
    close(): void;
}

declare class CometChannel extends ADataChannel {
    private _runtime;
    private _pid;
    private _sessionid;
    private _domain;
    private _isDisconnected;
    private _messageIds;
    private _syncMessageIds;
    private _protocol;
    constructor(_runtime: IRuntime, watcher: IDataChannelWatcher);
    /**
     * 长轮询结果处理
     * @param data
     */
    handleCometRes(res: IResponse): boolean;
    /**
     * 长轮询心跳
     */
    _startPullSignal(protocol: 'http' | 'https'): Promise<void>;
    /**
     * 连接
     *  comet 连接暂时不走 protocolVer=v4 的协议
     * @returns
     */
    connect(appkey: string, token: string, hosts: string[], protocol: 'http' | 'https', apiVersion: string, protocolVer: ConnAckProtocolVer): Promise<ErrorCode>;
    private _idCount;
    private _generateMessageId;
    sendCometData(writer: BaseWriter, timeout?: number): Promise<void>;
    sendOnly(writer: BaseWriter): void;
    send(writer: QueryWriter | PublishWriter, respPBName?: string, option?: any, timeout?: number): Promise<IAsyncRes>;
    close(): void;
}

declare enum NotificationStatus {
    /**
     * 免打扰已开启
    */
    OPEN = 1,
    /**
     * 免打扰已关闭
    */
    CLOSE = 2
}

/**
 * 已读回执数据结构
 */
interface IMessageReader {
    readTime: number;
    userId: string;
}
interface IMessageReaderResponse {
    totalMemberCount: number;
    list: IMessageReader[];
}
interface ILocalReadReceiptInfo {
    hasRespond?: boolean;
    readerInfo?: {
        [userId: string]: number;
    };
    readCount?: number;
    totalCount?: number;
}
interface IReadReceiptInfo {
    /**
     * 是否已经发送已读回执
     */
    hasRespond?: boolean;
    /**
     * 已阅读用户列表（不准确）
     */
    readerList?: IMessageReader[];
    /**
     * 阅读人数（不准确）
     */
    readCount?: number;
    /**
     * 群组总人数（不准确）
     */
    totalCount?: number;
}

/**
 * 从服务端接收到的消息数据
 */
interface IReceivedMessage {
    /**
     * 会话的业务标识
    */
    channelId?: string;
    /**
     * 会话类型
     * * 1: 单聊
     * * 3: 群聊
     * * 4: 聊天室
     * * 5: 客服会话
     * * 6: 系统消息
     * * 7: 默认关注的公众号
     * * 8: 手动关注的公众号
     * * 9: RTCLib 房间
     */
    conversationType: ConversationType;
    /**
     * 会话 targetId
     */
    targetId: string;
    /**
     * 消息发送者的用户 Id
     */
    senderUserId: string;
    /**
     * 消息内容
     */
    content: any;
    /**
     * 消息结构名称，即消息类型
     * @example RC:TxtMsg
     */
    messageType: string;
    /**
     * 服务端存储的消息 Id
     */
    messageUId: string;
    /**
     * 消息方向是发出 or 收取
     */
    messageDirection: MessageDirection;
    /**
     * 是否为离线消息
     */
    isOffLineMessage: boolean;
    /**
     * 消息在服务器端的发送时间
     */
    sentTime: number;
    /**
     * 消息接收时间，该时间通过消息的 `sentTime` 值在本地进行计算得出，不推荐使用
     * @description 当 isOffLineMessage 为 true 时，该值无效
     */
    receivedTime: number;
    /**
     * 是否存储
     * @default true
     */
    isPersited: boolean;
    /**
     * 是否计数
     * @default true
     */
    isCounted: boolean;
    /**
     * 是否为 @ 消息
     */
    isMentioned: boolean;
    /**
     * 消息是否静默
     * @description 静默消息不会发送 Push 信息和本地通知提醒
     */
    disableNotification: boolean;
    /**
     * 是否是状态消息
     */
    isStatusMessage: boolean;
    /**
     * 是否支持消息扩展存储
    */
    canIncludeExpansion: boolean;
    /**
     * 消息携带的扩展存储
    */
    expansion: {
        [key: string]: any;
    } | null;
    /**
     * 消息接收状态
    */
    receivedStatus: number;
    /**
     * CPP 独有字段 消息本地 ID
    */
    messageId?: number;
    /**
     * CPP 独有字段 消息发送状态
    */
    sentStatus?: number;
    /**
     * 已读回执信息(导航配置grpRRVer=1时群组类型消息内存在, 其他情况为undefined)
     */
    readReceiptInfo?: IReadReceiptInfo;
    /**
     * 推送扩展
     */
    pushConfig?: IPushConfig;
}

/**
 * 从服务器拉取到的会话数据结构
 */
interface IReceivedConversation {
    /**
     * 会话的业务标识
    */
    channelId?: string;
    /**
     * 会话类型
     */
    conversationType: ConversationType;
    /**
     * 会话 Id
     * @description
     * 1. 当 `conversationType` 为 `ConversationType.GROUP` 时，该值为群组 Id
     * 1. 当 `conversationType` 为 `ConversationType.PRIVATE` 时，该值为对方用户 Id
     */
    targetId: string;
    /**
     * 当前会话的未读消息数
     */
    unreadMessageCount: number;
    /**
     * 会话中的最后一条消息
     */
    latestMessage: IReceivedMessage | null;
    /**
     * 是否包含 @ 自己的消息，此数据仅在 `conversationType` 为 `ConversationType.GROUP` 时有效
     */
    hasMentioned?: boolean;
    /**
     * 消息中的 @ 数据，仅在 `conversationType` 为 `ConversationType.GROUP` 时有效
     */
    mentionedInfo?: {
        /**
         * `@ 类型，其中 1 为 @ 所有人，2 为 @ 部分人`
         */
        type: 1 | 2;
        /**
         * 被 @ 的用户 Id 列表，仅在 `type` 为 `2` 时有效
         */
        userIdList: string[];
    } | null;
    /**
     * 会话免打扰状态
     * @description
     * 1. 已开启免打扰
     * 2. 未开启免打扰
     */
    notificationStatus: NotificationStatus;
    /**
     * 会话是否已置顶
     */
    isTop: boolean;
    /**
     * 会话中消息的最后未读时间
     */
    lastUnreadTime: number;
    /**
     * 搜索到的会话数量
     */
    matchCount?: number;
}
interface IReceivedConversationByTag extends IReceivedConversation {
    isTopInTag: boolean;
}

/**
 * 设置会话状态 参数 信息
*/
interface ISetConversationStatusOptions {
    conversationType: ConversationType;
    targetId: string;
    isTop?: boolean;
    notificationStatus?: number;
    channelId?: string;
}

interface IChatroomUser {
    /**
     * 用户 id
     */
    id: string;
    /**
     * 加入聊天室的时间
     */
    time: number;
}

interface IChatroomInfo {
    /**
     * 成员列表
     * @todo 需确认数组元素的数据结构
     */
    userInfos: IChatroomUser[];
    /**
     * 房间内总人数
     */
    userCount: number;
}

interface IUploadAuth {
    /**
     * 七牛 token 有效期
    */
    deadline: number;
    /**
     * 七牛上传 token
    */
    token: string;
    /**
     * 百度上传 token
    */
    bosToken: string;
    /**
     * 百度上传 header Date
    */
    bosDate: string;
    /**
     * 百度上传路径
    */
    path: string;
    /**
     * 上传文件名，阿里上传获取下载地址时，必须使用上传文件名，所以需抛出到业务端
     */
    fileName: string;
    /**
     * 阿里云 oss 的 AccessKeyId
     */
    osskeyId: string;
    /**
     * 阿里云 oss post 请求表单域中的字段 policy
     */
    ossPolicy: string;
    /**
     * 阿里云 oss 根据 policy 计算的签名信息
     */
    ossSign: string;
    /**
     * 阿里云 oss 存储空间名称
     */
    ossBucketName: string;
    /**
     * s3 认证凭证，对应 post上传 x-amz-credential 字段
     */
    s3Credential: string;
    /**
     * 加密算法，对应 post上传 x-amz-algorithm 字段
     */
    s3Algorithm: string;
    /**
     * s3 日期，对应 post上传 x-amz-date 字段
     */
    s3Date: string;
    /**
     * s3 policy，对应 post上传 policy 字段
     */
    s3Policy: string;
    /**
     * s3 签名信息，对应 post上传 x-amz-signature 字段
     */
    s3Signature: string;
    /**
     * s3 存储空间名称
     */
    s3BucketName: string;
    /**
     * stc  Authorization 头
     */
    stcAuthorization: string;
    /**
     * stc  xAmzContentSha256
     */
    stcContentSha256: string;
    /**
     * stc date
     */
    stcDate: string;
    /**
     * stc 存储空间名称
     */
    stcBucketName: string;
}

interface IUpdatedExpansion {
    expansion: {
        [key: string]: any;
    };
    messageUId: string;
    channelId?: string;
}
interface IDeletedExpansion {
    deletedKeys: string[];
    messageUId: string;
    channelId?: string;
}
interface IExpansionListenerData {
    updatedExpansion?: IUpdatedExpansion;
    deletedExpansion?: IDeletedExpansion;
}

interface IRTCUsers {
    users: {
        [userId: string]: {
            /**
             * 发布的资源数据，是一个 JSON 字符串，解析后为发布的资源列表
             */
            uris?: string;
        };
    };
}

interface IRtcTokenData {
    rtcToken: string;
}

interface KVString {
    [key: string]: string;
}

interface IRTCRoomInfo {
    roomId: string;
    roomData: unknown[];
    userCount: number;
    list: unknown[];
}

interface IJoinRTCRoomData extends IRTCUsers {
    token: string;
    sessionId: string;
    roomInfo: {
        key: string;
        value: string;
    }[];
}

/**
 * 文件类型
 */
declare enum FileType {
    /**
     * 图片文件
     */
    IMAGE = 1,
    /**
     * 声音文件
     */
    AUDIO = 2,
    /**
     * 视频文件
     */
    VIDEO = 3,
    /**
     * 非媒体文件
     */
    FILE = 4,
    /**
     * 小视频类型
    */
    SIGHT = 5,
    /**
     * 合并转发
    */
    COMBINE_HTML = 6
}

declare enum UploadMethod {
    /**
     * 七牛上传
     */
    QINIU = 1,
    /**
     * 阿里云上传
     */
    ALI = 2,
    /**
     * 亚马逊上传
     */
    AWS = 3,
    /**
     * stc上传
     */
    STC = 4
}

interface IRecallMsgOptions {
    /**
     * 会话组织机构标识
     * 默认值未 空字符串
    */
    channelId: string;
    /**
     * 发送消息携带的用户信息
    */
    user?: IUserProfile;
    /**
     * Push 信息
    */
    pushContent?: string;
    /**
     * 原消息体
    */
    oriContent?: any;
    /**
     * 是否发送静默消息
     * @description
     * 当值为 `true` 时，服务器将不会发送 Push 信息，移动端也不会弹出本地通知提醒
    */
    disableNotification?: boolean;
    /**
     * 移动端推送配置
    */
    pushConfig?: IPushConfig;
}

interface IInsertMsgOptions {
    senderUserId: string;
    messageType: string;
    content: string;
    messageDirection: number;
    readStatus?: number;
    sentStatus?: number;
    sentTime?: number;
    searchContent?: string;
    isUnread?: boolean;
    messageUId?: string;
    disableNotification?: boolean;
    canIncludeExpansion?: boolean;
    expansionMsg?: string;
    channelId: string;
}

interface IChatroomEntry {
    /**
     * 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    key: string;
    /**
     * 属性对应的值, 最大长度 4096 字符
     */
    value: string;
    /**
     * 设置成功后是否发送通知消息
     */
    isSendNotification?: boolean;
    /**
     * RC:chrmKVNotiMsg 消息中携带的附加信息
     */
    notificationExtra?: string;
    /**
     * 用户退出聊天室时是否清除此属性
     */
    isAutoDelete?: boolean;
}

interface IChatroomEntries {
    /**
     * entries ,要设置的属性列表
     * key 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     * value 属性对应的值, 最大长度 4096 字符
     */
    entries: {
        key: string;
        value: string;
    }[];
    /**
     * 用户退出聊天室时是否清除此属性
     */
    isAutoDelete?: boolean;
}

interface IRemoveChatRoomEntryOption {
    /**
     * 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    key: string;
    /**
     * 删除成功后是否发送通知消息
     */
    isSendNotification?: boolean;
    /**
     * RC:chrmKVNotiMsg 消息中携带的附加信息
     */
    notificationExtra?: string;
}

interface IRemoveChatRoomEntriesOption {
    /**
     * key 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    entries: {
        key: string;
    }[];
}

/**
 * 聊天室成员进入和退出状态
 */
declare enum ChatroomUserChangeType {
    QUIT = 0,
    JOIN = 1
}

interface IChatroomEntryListenerData {
    /**
     * 更新的键
    */
    key: string;
    /**
     * 更新的值
    */
    value: string;
    /**
     * 更新的时间
    */
    timestamp: number;
    /**
     * 更新的聊天室 ID
    */
    chatroomId: string;
    /**
     * 更新类型
    */
    type: ChatroomEntryType;
}
interface IChatroomRejoinedFailed {
    /**
     * 自动重新加入的聊天室 ID
    */
    chatroomId: string;
    /**
     * 自动重新加入失败的 code
    */
    errorCode: number;
}
interface IChatroomRejoinedSuccessed {
    /**
     * 自动重新加入的聊天室 ID
    */
    chatroomId: string;
    /**
     * 自动重新加入的聊天室拉取消息的数量
    */
    count: number;
}
interface IChatroomUserChangeInfo {
    users: {
        [userId: string]: ChatroomUserChangeType;
    };
    chatroomId: string;
}
declare type IChatroomRejoinedInfo = IChatroomRejoinedFailed | IChatroomRejoinedSuccessed;
/**
 * 聊天室信息
*/
interface IChatroomListenerData {
    /**
     * SDK 内部重连聊天室信息
    */
    rejoinedRoom?: IChatroomRejoinedInfo;
    /**
     * 监听到的聊天室 KV 更新
    */
    updatedEntries?: IChatroomEntryListenerData[];
    userChange?: IChatroomUserChangeInfo;
    /**
     * 聊天室销毁
     */
    chatroomDestroyed?: string;
}

interface IUpdatedConversation {
    updatedItems: {
        [key: string]: {
            time: number;
            val: any;
        };
    };
    conversationType: number;
    targetId: string;
    latestMessage?: IReceivedMessage;
    unreadMessageCount?: number;
    hasMentioned?: boolean;
    mentionedInfo?: {
        /**
         * `@ 类型，其中 1 为 @ 所有人，2 为 @ 部分人`
         */
        type: 1 | 2;
        /**
         * 被 @ 的用户 Id 列表，仅在 `type` 为 `2` 时有效
         */
        userIdList: string[];
    };
    lastUnreadTime?: number;
    notificationStatus?: number;
    isTop?: boolean;
    /**
     * 会话标识
    */
    channelId?: string;
    tags?: IUpdatedConversation[];
}

/**
 * 加入 RTC 房间的用户信息
 */
interface IRTCJoinedInfo {
    /**
     * 设备 ID
     */
    deviceId: string;
    /**
     * RTC 房间 ID
     */
    roomId: string;
    /**
     * 加入的时间戳
     */
    joinTime: number;
}

declare class PluginContext {
    protected readonly _context: APIContext;
    constructor(_context: APIContext);
    /**
     * 接收 IM 服务推送的消息，并通过返回 boolean 值决定此消息是否拦截
     * @param message
     * @returns 当返回值为 true，接收的消息将终止继续传递
     */
    onmessage?(message: IReceivedMessage): boolean;
    /**
     * 用户主动断开连接的事件通知
     */
    ondisconnect?(): void;
    /**
     * 接收 IM 连接状态变更通知
     * @param status
     */
    onconnectionstatechange?(status: ConnectionStatus): void;
    /**
     * IM 客户端销毁通知
     */
    ondestroy?(): void;
    /**
     * RTC 数据通知
     * @param roomdId 数据对应的房间 Id
     * @param data 通知数据为 key:value 方式
     * @description
     * 目前仅通知：主播加入、退出房间的人员列表变更，发布、取消发布资源列表变更
    */
    onrtcdatachange?(data: IServerRTCRoomEntry[], roomdId?: string): void;
    /**
     * 获取 `@rongcloud/engine` 包版本
     */
    getCoreVersion(): string;
    /**
     * 获取当前运行中的 IMLib 版本号
     */
    getAPIVersion(): string;
    /**
     * 获取当前应用的 appkey
     */
    getAppkey(): string;
    /**
     * 获取当前已连接用户的 userId
     * 用户连接建立之前及 disconnect 之后，该方法返回 '' 值
     */
    getCurrentId(): string;
    /**
     * 获取当前连接状态
     */
    getConnectionStatus(): ConnectionStatus;
    getDeviceId(): string;
    /**
     * 发送消息
     */
    sendMessage(conversationType: ConversationType, targetId: string, options: ISendMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 消息注册
     * @description 消息注册需在应用初始化完成前进行
     * @param objectName 消息类型，如：RC:TxtMsg
     * @param isPersited 是否存储
     * @param isCounted 是否技术
     * @param searchProps 搜索字段，只在搭配协议栈使用时有效
     */
    registerMessageType(objectName: string, isPersited: boolean, isCounted: boolean, searchProps?: string[]): void;
    /**
     * 获取服务时间
     */
    getServerTime(): number;
    /**
     * 获取加入 RTC 房间的用户信息（当前仅能查自己的）
     */
    getRTCJoinedUserInfo(userId: string): IPromiseResult<IRTCJoinedInfo[]>;
}

declare enum ReceivedStatus {
    /**
     * 已读
    */
    READ = 1,
    /**
     * 已听
    */
    LISTENED = 2,
    /**
     * 已下载
    */
    DOWNLOADED = 4,
    /**
     * 该消息已经被其他登录的多端收取过。( 即该消息已经被其他端收取过后。当前端才登录，并重新拉取了这条消息。客户可以通过这个状态更新 UI，比如不再提示 )
    */
    RETRIEVED = 8,
    /**
     * 未读
    */
    UNREAD = 0
}

/**
 * CMP/Comet 服务连接应答码
 */
declare const ConnectResultCode: {
    /**
     * 连接成功
     */
    ACCEPTED: number;
    /**
     * 协议版本不匹配
     * @description 暂未使用
     */
    UNACCEPTABLE_PROTOCOL_VERSION: number;
    /**
     * 客户端（移动端 TCP 连接建立时）`info` 字段格式错误
     * @description 格式：`{平台类型}-{设备信息}-{sdk版本}`。
     * 其中设备信息为：{手机类型}{手机型号}{网络类型，4G/WIFI}{运营商标识, 移动/电信/联通}
     */
    IDENTIFIER_REJECTED: number;
    /**
     * 不支持的平台类型，一般小程序或 PC 未开通
     */
    SERVER_UNAVAILABLE: number;
    /**
     * Token无法解析，或Token已过期
     */
    TOKEN_INCORRECT: number;
    /**
     * 防黑产规则相关应答
     */
    NOT_AUTHORIZED: number;
    /**
     * 服务重定向，一般服务扩缩容时，落点已经改变，此时 userId 链接到旧的节点时，会触发该错误。
     * 客户端收到该应答后须重新访问导航，重新获取 CMP 地址
     */
    REDIRECT: number;
    /**
     * 暂未使用
     */
    PACKAGE_ERROR: number;
    /**
     * 该 AppKey 已经封禁或删除
     */
    APP_BLOCK_OR_DELETE: number;
    /**
     * 该用户 ID 已经被封禁
     */
    BLOCK: number;
    /**
     * Token 已过期，暂未使用
     */
    TOKEN_EXPIRE: number;
    /**
     * Token 中携带 deviceId 时，检测 Token 中 deviceId 与链接设备 deviceId 不一致
     */
    DEVICE_ERROR: number;
    /**
     * Web 端设置安全域名后，连接端域名不在安全域名范围内
     */
    HOSTNAME_ERROR: number;
    /**
     * 开启`禁止把已在线客户端踢下线`开关后，该错误码标识已有同类型端在线，禁止链接
     */
    HASOHTERSAMECLIENTONLINE: number;
    /**
     * 客户端连错环境，引发连接拒绝
     */
    IN_OTHER_CLUSTER: number;
    /**
     * app 验证Token 验证不通过。所有内部超时，访问失败,返回给客户端sdk都是验证不通过，由服务端日志去看具体是那种失败。
     */
    APP_AUTH_NOT_PASS: number;
    /**
     * One Time Password 已经被使用过
     */
    OTP_USED: number;
    /**
     * token平台验证失败
     */
    PLATFORM_ERROR: number;
};

/**
 * 内置消息类型
 */
declare enum MessageType {
    /**
     * 文字消息
    */
    TextMessage = "RC:TxtMsg",
    /**
     * 语音消息
    */
    VOICE = "RC:VcMsg",
    /**
     * 高质量消息
    */
    HQ_VOICE = "RC:HQVCMsg",
    /**
     * 图片消息
    */
    IMAGE = "RC:ImgMsg",
    /**
     * GIF 消息
    */
    GIF = "RC:GIFMsg",
    /**
     * 图文消息
    */
    RICH_CONTENT = "RC:ImgTextMsg",
    /**
     * 位置消息
    */
    LOCATION = "RC:LBSMsg",
    /**
     * 文件消息
    */
    FILE = "RC:FileMsg",
    /**
     * 小视频消息
    */
    SIGHT = "RC:SightMsg",
    /**
     * 合并转发消息
    */
    COMBINE = "RC:CombineMsg",
    /**
     * 聊天室 KV 通知消息
    */
    CHRM_KV_NOTIFY = "RC:chrmKVNotiMsg",
    /**
     * 日志通知消息
    */
    LOG_COMMAND = "RC:LogCmdMsg",
    /**
     * 消息扩展
    */
    EXPANSION_NOTIFY = "RC:MsgExMsg",
    /**
     * 引用消息
    */
    REFERENCE = "RC:ReferenceMsg",
    /**
     * 撤回消息
    */
    RECALL = "RC:RcCmd",
    /**
     * 已读同步状态消息
    */
    READ_RECEIPT = "RC:ReadNtf",
    /**
     * 群已读请求回执消息
    */
    READ_RECEIPT_REQUEST = "RC:RRReqMsg",
    /**
     * 群已读响应回执消息
    */
    READ_RECEIPT_RESPONSE = "RC:RRRspMsg",
    /**
     * 多端同步已读状态
    */
    SYNC_READ_STATUS = "RC:SRSMsg",
    /**
     * 接受群已读回执更新消息(导航开关grpRRVer为1时使用)
     */
    GROUP_READ_RECEIPT_REQUEST = "RC:RRMsg",
    /**
     * 用户加入聊天室
     */
    CHATROOM_JOIN = "RC:ChrmJoinNtf",
    /**
     * 用户退出聊天室
     */
    CHATROOM_LEFT = "RC:ChrmQuitNtf",
    /**
     * 用户加入退出聊天室的集合
     */
    CHATROOM_MERGE_CHANGE = "RC:ChrmMemChange",
    /**
     * 输入状态消息
     */
    TYPING_STATUS = "RC:TypSts",
    /**
     * 拦截消息,（当发送的消息的敏感词时，服务会下发一个拦截消息，内容包含被拦截消息信息）
     */
    INTERCEPT = "RC:InterceptMsg"
}

/**
 * 群组 @ 类型
*/
declare enum MentionedType {
    /**
     * 所有人
    */
    ALL = 1,
    /**
     * 部分人
    */
    SINGAL = 2
}

interface IMetionedData {
    type?: MentionedType;
    userIdList?: string[];
    mentionedContent?: string;
}

declare enum LogLevel {
    /**
     * 等同于 `LogLevel.DEBUG`
     */
    LOG = 0,
    /**
     * 0
     */
    DEBUG = 0,
    /**
     * 1
     */
    INFO = 1,
    /**
     * 2
     */
    WARN = 2,
    /**
     * 3
     */
    ERROR = 3,
    /**
     * 4
     */
    FATAL = 4,
    /**
     * 不展示任何日志
     */
    NONE = 1000
}

declare enum LogType {
    IM = "IM",
    RTC = "RTC"
}

/**
 * 导航信息数据就结构
 */
interface INaviInfo {
    /**
     * Navi 数据请求响应码，200 为成功请求
     */
    code: number;
    /**
     * 获取 Navi 数据失败时的提示信息
     */
    errorMessage?: string;
    /**
     * 获取 Navi 数据失败时的请求 url 信息
     */
    url?: string;
    /**
     * 请求导航数据时使用的协议：http / https
     * @description 该字段为 SDK 内增加的字段，导航接口数据中不存在
     */
    protocol: 'http' | 'https';
    /**
     * 获取导航时使用的 userId，小程序不走导航，故拿不到 userId
     */
    userId?: string;
    /**
     * CMP 服务 Websocket 连接地址，包含域名与端口，不含 ws 或 wss 协议头
     * @example a.domain.com:443
     */
    server: string;
    /**
     * 备用 CMP 服务地址，包含域名与端口，不含 ws 或 wss 协议头，多个备用地址以 ',' 分割
     * @example a.domain.com:443,b.domain.com:443
     */
    backupServer?: string;
    /**
     * 备用 CMP 服务地址，POST 请求 TCP 连接返回的是 bs 字段，非 backupServer 字段
     */
    bs?: string;
    /**
     * RTC 服务配置，其值可能为 null、无效字符串、有效 JSON 字符串
     * 1. 公有云未开通音视频时，值为 null
     * 2. 私有云无配置时为 `{ "strategy": 0 }`
     */
    voipCallInfo: string | null;
    /**
     * 聊天室 kv 存储开关
     * @todo 需确认详细有效值
     * @description 公有云独有配置
     */
    kvStorage: number;
    /**
     * HttpDNS 功能开关，在 web 端无效
     * @description 公有云独有配置
     */
    openHttpDNS: boolean;
    /**
     * 历史消息云存储功能开关
     * @description
     * 1. 公有云通过 `developer.rongcloud.cn` 管理后台 `单群聊消息云端存储` 功能开关进行配置
     * 2. 私有云默认为 `true`
     */
    historyMsg: boolean;
    /**
     * 聊天室历史消息开关
     * @description
     * 1. 私有云对聊天室功能支持有限，默认为 `false`
     * 2. TODO: 公有云配置待确认
     */
    chatroomMsg: boolean;
    /**
     * 文件服务器地址
     * @description
     * 1. 公有云下，该地址为七牛云服务器地址
     * 2. 私有云下，该地址为私有云自研文件服务器地址
     */
    uploadServer: string;
    /**
     * 实时位置共享配置，web 端无需处理
     */
    location: null | string;
    /**
     * 实时日志上传开关
     * @todo 需确认有效值及作用
     */
    monitor: number;
    /**
     * 是否允许加入多聊天室开关
     */
    joinMChrm: boolean;
    /**
     * 是否开启公众号功能：`0` 为未开启，`1` 为已开启
     */
    openMp: 0 | 1;
    /**
     * 是否开启用户级配置，若开启，需连接成功后立即拉取实时配置，0 | 1
     * @description
     * 配置来源:
     * 1. 导航
     * 2. 服务端实时下发
     * 已有配置字段:
     * 1. Lan. 推送使用的语言设置，用户端可自定义修改. Web 端未做设置, 只做接收
     * 2. ShPushSwit. 推送是否显示详情设置，用户端可自定义修改. Web 端未做设置, 只做接收
     * 3. MobPushSwit: Web/PC 在线，移动端不在线是否发送推送开关，用户端可自定义修改. Web 端未做设置, 只做接收
     * 4. OffMsgDur: 离线消息保存天数，设置天数不可大于App级对应配置，用户端可自定义修改. Web 端未做设置, 只做接收
     * 5. VoipInfo: 音视频相关配置，用户端不可自定义修改. 由服务端决定，与导航下发格式一致
     * @todo 需确认公有云与私有云区别
     */
    openUS: 0 | 1;
    /**
     * 群离线消息最大下发条数，`0` 为关闭
     * @description 公有云独有配合
     */
    grpMsgLimit: number;
    /**
     * 消息加密开关，0 为关闭
     * @todo
     * 1. 确定其控制的功能
     * 2. 确定 web 相关性
     */
    isFormatted: number;
    /**
     * GIF 动图大小限制，默认 2048 KB
     */
    gifSize: number;
    /**
     * 上传小视频时长限制，单位：秒
     * @description 公有云字段，即私有云配置中的 `uploadVideoTimeLimit`
     */
    videoTimes?: number;
    /**
     * 上传小视频时长限制，单位：秒
     * @description 私有云字段，即公有云配置中的 `videoTimes`
     */
    uploadVideoTimeLimit?: number;
    /**
     * 实时日志上传开关：`0` 为关闭，`1` 为开启
     */
    logSwitch: number;
    /**
     * 实时日志上传策略
     * @example `'{ "url": "logcollection.ronghub.com", "level": 1,"itv": 6, "times": 5 }'`
     */
    logPolicy: string;
    /**
     * 百度 BOS 存储服务地址
     * @description 公有云独有配置
     * @example `gz.bcebos.com`
     */
    bosAddr?: string;
    /**
     * 阿里上传配置，字符串数组，数组顺序代表 七牛、百度、阿里云 上传权重
     * @example "[{"qiniu":"upload.qiniup.com","p":"1"},{"baidu":"gz.bcebos.com","p":"2"},{"aliyun":"oss-cn-beijing.aliyuncs.com","p":"3"}]"
     */
    ossConfig?: string;
    /**
     * 私有云专有属性，可用来判断当前环境是公有云还是私有云，私有云环境下该值为 `1`
     */
    type?: number;
    /**
     * @deprecated 已废弃
     */
    compDays: number;
    /**
     * @deprecated 已废弃
     */
    msgAck: unknown;
    /**
     * @deprecated 已废弃
     */
    activeServer: string;
    /**
     * @deprecated 已废弃
     */
    qnAddr: string;
    /**
     * @deprecated 已废弃
     */
    extkitSwitch: number;
    /**
     * @deprecated 已废弃
     */
    alone: boolean;
    /**
     * @deprecated 已废弃
     */
    voipServer: string;
    /**
     * 离线日志上报地址
     * @deprecated 已废弃
     */
    offlinelogserver: string;
    /**
     * 在线日志上报地址
     * @deprecated 已废弃
     */
    onlinelogserver?: string;
    /**
     * 链路加密字段，内容为 JSON 字符串，仅限 C++ 可用
     */
    crypto?: string;
    /**
     * 群组回执开关, 1: 打开，0(或者没有): 关闭
     */
    grpRRVer?: number;
    /**
     * 防黑产开关, 1: 打开，0：关闭
     */
    openAnti?: number;
}

/**
 * 拓展方法定义，便于 electron-solution 实现时保持接口类型推导可用
 */
interface IExtraMethod {
    getConversationsByPage(conversationTypes: ConversationType[], sentTime: number, count: number, channelId?: string): Promise<IAsyncRes<IReceivedConversation[]>>;
    getHistoryMessagesByObjectNames(conversationType: ConversationType, targetId: string, sentTime: number, count: number, objectNames: string[], desc: 0 | 1, tag: string): Promise<IAsyncRes<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>>;
    updateMessageReceiptStatus(conersationType: ConversationType, targetId: string, timestamp: number, channelId?: string): Promise<IAsyncRes<boolean>>;
}

/**
 * typing相关接口
 */

/**
 * typing信息
 */
interface ITypingUser {
    userId: string;
    timestamp: number;
    messageType: string;
}
/**
 * 内存存储typing，key为conversationType_targetId
 */
interface ITypingInfo {
    [key: string]: Array<ITypingUser>;
}
/**
 * typing通知消息接口
 */
interface ITypingMessage {
    targetId: string;
    conversationType: ConversationType;
    channelId?: string;
    list: Array<ITypingUser>;
}

/**
 * 消息被拦截类型
 */
declare enum MessageBlockType {
    /*!
    全局敏感词：命中了融云内置的全局敏感词
   */
    GLOBAL = 1,
    /*!
     自定义敏感词拦截：命中了客户在融云自定义的敏感词
    */
    CUSTOM = 2,
    /*!
     第三方审核拦截：命中了第三方（数美）或模板路由决定不下发的状态
    */
    THIRD_PARTY = 3
}

/**
 * 被拦截的消息信息
 */
interface IBlockedMessageInfo {
    blockedMessageUId: string;
    conversationType: number;
    targetId: string;
    blockType: MessageBlockType;
}

interface IConnectResult {
    /**
     * 连接错误码
     */
    code: ErrorCode;
    /**
     * 导航获取成功后即可有相应的值，在导航数据获取完成之前该值为 undefined
     */
    userId?: string;
}
declare type IMessageListnenr = (message: IReceivedMessage, leftCount?: number, hasMore?: boolean) => void;
declare type IConnectionStatusListener = (status: ConnectionStatus) => void;
declare type IConversationStateListener = (conversation: IUpdatedConversation[]) => void;
declare type IChatroomListener = (state: IChatroomListenerData) => void;
declare type IRTCInnerListener = {
    message?: IMessageListnenr;
    status?: IConnectionStatusListener;
};
declare type IExpansionListener = (data: IExpansionListenerData) => void;
declare type ITagListener = () => void;
declare type IConversationTagListener = () => void;
declare type ItypingStateListener = (data: ITypingMessage[]) => void;
declare type IMessageBlockedListener = (data: IBlockedMessageInfo) => void;
interface ISendExMsgOptions {
    channelId: string;
    conversationType: ConversationType;
    targetId: string;
    /**
     * 消息 ID
    */
    messageUId: string;
    /**
     * 原始消息是否支持扩展的字段
    */
    canIncludeExpansion: boolean;
    /**
     * 删除的 keys
    */
    keys?: string[];
    /**
     * 扩展对象
    */
    expansion?: {
        [key: string]: string;
    };
    /**
     * 是否删除所有扩展
    */
    removeAll?: boolean;
    /**
     * 原始消息的扩展
    */
    originExpansion?: {
        [key: string]: string;
    } | null;
}
interface IWatcher {
    message?: IMessageListnenr;
    connectionState?: IConnectionStatusListener;
    conversationState?: IConversationStateListener;
    chatroomState?: IChatroomListener;
    expansion?: IExpansionListener;
    /**
     * 为兼容老版本 RTCLib 与 CallLib 接收消息的方式，新版本消息走插件机制
     */
    rtcInnerWatcher?: IRTCInnerListener;
    /**
     * 标签的增删改监听
     */
    tag?: ITagListener;
    /**
     * 会话中标签状态变更监听
     */
    conversationTagChanged?: IConversationTagListener;
    /**
     * 输入状态变更监听
     */
    typingState?: ItypingStateListener;
    /**
     * 是否拉取完毕添加通知
     */
    pullFinished?: ITagListener;
    /**
     * 敏感词被拦截监听
     */
    messageBlocked?: IMessageBlockedListener;
}
interface IPluginGenerator<API, InitOption> {
    /**
     * 只读插件标识
     */
    readonly tag: string;
    /**
     * 版本号
     */
    readonly version?: string;
    /**
     * 插件名称
     */
    readonly name?: string;
    /**
     * 插件安装前的环境检测，通过返回 boolean 值确认插件是否可运行
     */
    verify(runtime: IRuntime): boolean;
    /**
     * 插件初始化
     * @param context 插件调用上下文，用于实现插件的消息注册、消息首发等
     * @param runtime 运行时实例，用于标识最终的运行时平台
     * @param options 初始化参数
     */
    setup(context: PluginContext, runtime: IRuntime, options: InitOption): API;
}
interface IAPIContextOption {
    /**
     * 应用 appkey
     */
    appkey: string;
    /**
     * IMLib 版本号
     */
    apiVersion: string;
    /**
     * 自定义导航地址:
     * 1. 私有云环境下该值为必填项
     * 2. 当存在自定义导航地址时，SDK 内部默认地址将无效
     * 3. 当存在自定义导航地址时，地址 url 中需包含 http/https 协议头，否则视为无效值
     * 4. 建立 ws/wss 连接前的 ping 接口使用的协议与导航 url 中的协议相同
     * 5. 建立 websocket 建立连接时将根据 ping 接口使用的 http/https 协议来确定使用 ws/wss 协议
     * 6. 动态导航使用的协议头将与自定义导航地址相同
     * 7. 公有云默认使用 https 协议
     */
    navigators: string[];
    /**
     * (参数已废弃)~~c++ 协议栈数据库地址~~
     * @deprecated
    */
    dbPath?: string;
    /**
     * 小程序的 CMP 代理地址
     */
    miniCMPProxy: string[];
    /**
     * 指定默认使用的连接类型
     */
    connectionType: 'websocket' | 'comet';
    /**
     * 修改 engine log 打印等级
     */
    logLevel?: LogLevel;
    /**
     * 修改默认的 log 输出函数
     */
    logStdout?: (logLevel: LogLevel, content: string) => void;
    /**
     * （已废弃）私有云标识
     * @deprecated
     */
    isEnterPrise?: boolean;
    /**
     * typing状态过期时间
     */
    typingExpireTime?: number;
    /**
     * 是否打开 IndexDB 存储，默认为 true
     */
    indexDBSwitch?: boolean;
    /**
     * 是否校验证书，默认为 true
     */
    checkCA?: boolean;
}
declare class APIContext {
    private _runtime;
    private static _context?;
    static init(runtime: IRuntime, options: IAPIContextOption): APIContext;
    static destroy(): void;
    private _token;
    /**
     * 插件队列，用于逐一派发消息与信令
     */
    private _pluginContextQueue;
    /**
     * 插件实例Map，用于重复初始化时返回实例
     */
    private _pluginInstanseMap;
    private readonly _engine;
    /**
     * 核心库版本号，后期与 4.0 IM SDK 版本号保持一致
     */
    readonly coreVersion: string;
    readonly appkey: string;
    readonly apiVersion: string;
    private readonly _options;
    private _versionInfo;
    private _typingInfo;
    /**
     * 内部连接状态标识，为 ture 时不允许调用 reconnect 方法
     */
    private _isInternalConnected;
    constructor(_runtime: IRuntime, options: IAPIContextOption);
    /**
     * 安装使用插件，并初始化插件实例
     * @param plugin
     * @param options
     */
    install<T, O>(plugin: IPluginGenerator<T, O>, options: O): T | null;
    private _connectionStatus;
    private _canRedirectConnect;
    /**
     * 重定向后，递归调用 connect
     */
    private _handleRedirect;
    /**
     * 连接状态变更回调
     * @param message
     */
    private _connectionStatusListener;
    private _messageReceiver;
    /**
     * 聊天室相关信息监听
    */
    private _chatroomInfoListener;
    /**
     * 会话监听相关
    */
    private _conversationInfoListener;
    /**
     * 消息扩展监听相关
    */
    private _expansionInfoListener;
    /**
     * 标签增删改监听
     */
    private _tagListener;
    /**
     * 会话标签状态监听
     */
    private _conversationTagListener;
    private _typingStatusListener;
    private _pullFinishedListener;
    private _MessageBlockedListener;
    /**
     * rtc 数据变更通知 pluginContext
     */
    private _rtcDataChange;
    /**
     * 业务层事件监听器挂载点
     */
    private _watcher;
    /**
     * 添加事件监听
     * @param options
     */
    assignWatcher(watcher: IWatcher): void;
    /**
     * 向内存中添加 typing 信息
     * 添加 typing 时不触发通知，只有在轮询时间点校验 _typingChangedList 的长度大于 0 时才通知
     */
    private _addTypingInfo;
    private _typingInternalTimer;
    private _typingExpireTime;
    private _typingChangedList;
    /**
     * 启动定时移除typing
     */
    private _startCheckTypingInfo;
    getConnectedTime(): number;
    getServerTime(): number;
    getDeviceId(): string;
    getCurrentUserId(): string;
    getConnectionStatus(): ConnectionStatus;
    /**
     * 建立连接，连接失败则抛出异常，连接成功后返回用户 userId，否则返回相应的错误码
     * @param token
     * @param refreshNavi 是否需要重新请求导航，当值为 `false` 时，优先使用有效缓存导航，若缓存失效则重新获取导航
     */
    connect(token: string, refreshNavi?: boolean): Promise<IConnectResult>;
    /**
     * 拉取实时配置 web 端需更新 voipCall 字段
     */
    private _pullUserSettings;
    disconnect(): Promise<void>;
    reconnect(): Promise<IConnectResult>;
    private _getTokenWithoutNavi;
    /**
     * 获取当前缓存的导航数据
     */
    getInfoFromCache(): INaviInfo | null;
    /**
     * 消息注册
     * @description 消息注册需在应用初始化完成前进行
     * @param objectName 消息类型，如：RC:TxtMsg
     * @param isPersited 是否存储
     * @param isCounted 是否技术
     * @param searchProps 搜索字段，只在搭配协议栈使用时有效
     */
    registerMessageType(objectName: string, isPersited: boolean, isCounted: boolean, searchProps?: string[]): void;
    /**
     * 发送消息
     * @param conversationType
     * @param targetId
     * @param objectName
     * @param content
     * @param options
     */
    sendMessage(conversationType: ConversationType, targetId: string, options: ISendMsgOptions, onBefore?: (messageId: number) => void): Promise<IAsyncRes<IReceivedMessage>>;
    /**
     * 发送扩展消息
     * @param messageUId 消息 Id
     * @param keys 需要删除的 key
     * @param expansion 设置的扩展
    */
    sendExpansionMessage(options: ISendExMsgOptions): Promise<IAsyncRes<ErrorCode>>;
    /**
     * 发送群组消息已读回执
     * 导航下发已读回执开关为 true 时调用
     * @param targetId 群组会话id
     * @param messageUIds 消息id
     */
    sendReadReceiptMessage(targetId: string, messageUIds: string[], channelId?: string): Promise<IAsyncRes>;
    /**
     * 获取群组消息已读列表
     * @param targetId
     * @param messageUIds
     */
    getMessageReader(targetId: string, messageUId: string, channelId?: string): Promise<IAsyncRes<IMessageReaderResponse>>;
    /**
     * 反初始化，清空所有监听及计时器
     */
    private _destroy;
    /**
     * @param conversationType
     * @param targetId 会话 Id
     * @param timestamp 拉取时间戳
     * @param count 拉取条数
     * @param order 1 正序拉取，0 为倒序拉取
     * @param channelId
     * @param objectName
     */
    getHistoryMessage(conversationType: ConversationType, targetId: string, timestamp?: number, count?: number, order?: 0 | 1, channelId?: string, objectName?: string): Promise<IAsyncRes<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>>;
    /**
     * 获取会话列表
     * @param count 指定获取数量, 不传则获取全部会话列表，默认 `300`
     */
    getConversationList(count?: number, conversationType?: ConversationType, startTime?: number, order?: 0 | 1, channelId?: string): Promise<IAsyncRes<IReceivedConversation[]>>;
    /**
     * 获取单一会话数据
     * @param conversationType
     * @param targetId
     * @param channelId
     */
    getConversation(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<IReceivedConversation | null>;
    /**
     * 删除会话
     */
    removeConversation(conversationType: ConversationType, targetId: string, channelId?: string): Promise<ErrorCode>;
    /**
     * 清除会话消息未读数
     */
    clearUnreadCount(conversationType: ConversationType, targetId: string, channelId?: string): Promise<ErrorCode>;
    /**
     * 获取指定会话消息未读数
     */
    getUnreadCount(conversationType: ConversationType, targetId: string, channelId?: string): Promise<IAsyncRes<number>>;
    /**
     * 获取所有会话未读数
     * @param channelId 多组织 Id
     * @param conversationTypes
     * @param includeMuted 包含已设置免打扰的会话
     */
    getTotalUnreadCount(channelId: string, conversationTypes?: ConversationType[], includeMuted?: boolean): Promise<IAsyncRes<number>>;
    /**
     * 获取第一个未读消息
     */
    getFirstUnreadMessage(conversationType: ConversationType, targetId: string, channelId?: string): Promise<IAsyncRes<IReceivedMessage | null>>;
    setConversationStatus(conversationType: ConversationType, targetId: string, isTop?: boolean, notificationStatus?: 1 | 2, channelId?: string): Promise<ErrorCode>;
    saveConversationMessageDraft(conversationType: ConversationType, targetId: string, draft: string): Promise<ErrorCode>;
    getConversationMessageDraft(conversationType: ConversationType, targetId: string): Promise<IAsyncRes<string>>;
    clearConversationMessageDraft(conversationType: ConversationType, targetId: string): Promise<ErrorCode>;
    recallMessage(conversationType: ConversationType, targetId: string, messageUId: string, sentTime: number, recallMsgOptions: IRecallMsgOptions): Promise<IAsyncRes<IReceivedMessage>>;
    /**
     * 删除远端消息
     * @param conversationType
     * @param targetId
     * @param list
     */
    deleteRemoteMessage(conversationType: ConversationType, targetId: string, list: {
        messageUId: string;
        sentTime: number;
        messageDirection: MessageDirection;
    }[], channelId?: string): Promise<ErrorCode>;
    /**
     * 根据时间戳删除指定时间之前的
     * @param conversationType
     * @param targetId
     * @param timestamp
     */
    deleteRemoteMessageByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, channelId?: string): Promise<ErrorCode>;
    /**
     * 加入聊天室，若聊天室不存在则创建聊天室
     * @param roomId 聊天室房间 Id
     * @param count 进入聊天室成功后，自动拉取的历史消息数量，默认值为 `10`，最大有效值为 `50`，`-1` 为不拉取
     */
    joinChatroom(roomId: string, count?: number): Promise<ErrorCode>;
    /**
     * 加入聊天室，若聊天室不存在则抛出异常
     * @param roomId 聊天室房间 Id
     * @param count 进入聊天室成功后，自动拉取的历史消息数量，默认值为 `10`，最大有效值为 `50`，`-1` 为不拉取
     */
    joinExistChatroom(roomId: string, count?: number): Promise<ErrorCode>;
    /**
     * 退出聊天室
     * @param roomId
     */
    quitChatroom(roomId: string): Promise<ErrorCode>;
    /**
     * 获取聊天室房间数据
     * @description count 或 order 有一个为 0 时，只返回成员总数，不返回成员列表信息
     * @param roomId 聊天室 Id
     * @param count 获取房间人员列表数量，最大有效值 `20`，最小值未 `0`，默认为 0
     * @param order 人员排序方式，`1` 为正序，`2` 为倒序，默认为 0
     */
    getChatroomInfo(roomId: string, count?: number, order?: 0 | 1 | 2): Promise<IAsyncRes<IChatroomInfo>>;
    /**
     * 在指定聊天室中设置自定义属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     * @param roomId 聊天室房间 id
     * @param entry 属性信息
     */
    setChatroomEntry(roomId: string, entry: IChatroomEntry): Promise<ErrorCode>;
    setChatroomEntries(roomId: string, entryOptions: IChatroomEntries): Promise<{
        code: ErrorCode;
        data?: any;
    }>;
    /**
     * 在指定聊天室中强制增加 / 修改任意聊天室属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     * @param roomId 聊天室房间 id
     * @param entry 属性信息
     */
    forceSetChatroomEntry(roomId: string, entry: IChatroomEntry): Promise<ErrorCode>;
    /**
     * 删除聊天室属性
     * @description 该方法仅限于删除自己设置的聊天室属性
     * @param roomId 聊天室房间 id
     * @param entry 要移除的属性信息
     */
    removeChatroomEntry(roomId: string, entry: IRemoveChatRoomEntryOption): Promise<ErrorCode>;
    /**
     * 批量删除聊天室属性
     * @description 该方法仅限于删除自己设置的聊天室属性
     * @param roomId 聊天室房间 id
     * @param entry 要移除的属性信息
     */
    removeChatroomEntries(roomId: string, entryOptions: IRemoveChatRoomEntriesOption): Promise<{
        code: ErrorCode;
        data?: any;
    }>;
    /**
     * 强制删除任意聊天室属性
     * @description 该方法仅限于删除自己设置的聊天室属性
     * @param roomId 聊天室房间 id
     * @param entry 要移除的属性信息
     */
    forceRemoveChatroomEntry(roomId: string, entry: IRemoveChatRoomEntryOption): Promise<ErrorCode>;
    /**
     * 获取聊天室中的指定属性
     * @param roomId 聊天室房间 id
     * @param key 属性键名
     */
    getChatroomEntry(roomId: string, key: string): Promise<IAsyncRes<string | null>>;
    /**
     * 获取聊天室内的所有属性
     * @param roomId 聊天室房间 id
     */
    getAllChatroomEntries(roomId: string): Promise<IAsyncRes<{
        [key: string]: string;
    }>>;
    /**
     * 拉取聊天室内的历史消息
     * @param roomId
     * @param count 拉取消息条数, 有效值范围 `1 - 20`
     * @param order 获取顺序，默认值为 0。
     * * 0：降序，用于获取早于指定时间戳发送的消息
     * * 1：升序，用于获取晚于指定时间戳发送的消息
     * @param timestamp 指定拉取消息用到的时间戳。默认值为 `0`，表示按当前时间拉取
     */
    getChatRoomHistoryMessages(roomId: string, count?: number, order?: 0 | 1, timestamp?: number): Promise<IAsyncRes<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>>;
    /**
     * 获取存储服务鉴权信息
     * @param fileType 文件类型
     * @param fileName 文件名称
     * @param httpMethod STC 分段上传时的必填参数，有效值为 PUT | POST
     * @param queryString STC 分段上传时的查询字符串
     * @description
     * `httpMethod` 与 `queryString` 为 STC S3 分段上传时的专属参数，STC 分段上传包含三个过程：
     * 1. 开始分段前调用，此时 `httpMethod` 值应为 `POST`， `queryString` 值为 `uploads`
     * 2. 上传请求前调用，此时 `httpMethod` 值应为 `PUT`，`queryString` 值为 `partNumber={partamNumer}&uploadId={uploadId}`
     * 3. 上传结束前调用，此时 `httpMethod` 值应为 `POST`，`queryString` 值为 `uploadId={uploadId}`
     * @returns
     */
    getFileToken(fileType: FileType, fileName?: string, httpMethod?: 'POST' | 'PUT', queryString?: string): Promise<IUploadAuth & {
        bos: string;
        qiniu: string;
    }>;
    /**
     * 获取 七牛、百度、阿里云 上传成功可下载的 URL
     * @param fileType 文件类型
     * @param fileName 文件名
     * @param saveName 下载后的存储文件名
     * @param uploadRes 插件上传返回的结果。降级百度上传后，用户传入返回结果，再把结果里的下载地址返回给用户，保证兼容之前结果获取
     * @param serverType 使用的存储服务标识
    */
    getFileUrl(fileType: FileType, fileName?: string, saveName?: string, uploadRes?: {
        isBosRes: boolean;
        downloadUrl: string;
    }, serverType?: UploadMethod): Promise<{
        downloadUrl: string;
    }>;
    /**
     * 创建标签
     * @param tag 标签
     */
    createTag(tag: ITagParam): Promise<IAsyncRes>;
    /**
     * 删除标签
     * @param tagId 标签id
     */
    removeTag(tagId: string): Promise<IAsyncRes>;
    /**
     * 更新标签
     * @param tag 标签
     */
    updateTag(tag: ITagParam): Promise<IAsyncRes>;
    /**
     * 获取标签列表
     */
    getTagList(): Promise<IAsyncRes<Array<ITagInfo>>>;
    /**
     * 添加会话到标签（给多个会话增加标签）
     * @param tagId 标签id
     * @param conversations 要添加的会话列表
     */
    addTagForConversations(tagId: string, conversations: IConversationOption[]): Promise<IAsyncRes<IAsyncRes>>;
    /**
     * 删除标签中的会话(从多个会话中批量删除指定标签)
     * @param tagId 标签id
     * @param conversations 要删除的会话列表
     */
    removeTagForConversations(tagId: string, conversations: IConversationOption[]): Promise<IAsyncRes<IAsyncRes>>;
    /**
     * 删除会话中的标签(从单一会话中批量删除标签)
     * @param conversationType 会话类型
     * @param targetId 会话id
     * @param tagIds 要删除的标签列表
     */
    removeTagsForConversation(conversation: IConversationOption, tagIds: string[]): Promise<IAsyncRes<IAsyncRes>>;
    /**
     * 获取标签下的会话列表
     * @param tagId 标签id
     */
    getConversationListByTag(tagId: string, startTime: number, count?: number, channelId?: string): Promise<IAsyncRes<IReceivedConversationByTag[]>>;
    /**
     * 获取标签下的未读消息数
     * @param tagId 标签id
     * @param containMuted 是否包含免打扰会话
     */
    getUnreadCountByTag(tagId: string, containMuted: boolean): Promise<IAsyncRes<number>>;
    /**
     * 设置标签中会话置顶
     * @param conversation 会话
     */
    setConversationStatusInTag(tagId: string, conversation: IConversationOption, status: {
        isTop: boolean;
    }): Promise<IAsyncRes<IAsyncRes>>;
    /**
     * 获取会话里的标签
     * @param conversation
     */
    getTagsForConversation(conversation: IConversationOption): Promise<IAsyncRes<IConversationTag[]>>;
    /**
     * 调用非标准方法。所谓非标准方法，是为某些特定需求或产品添加，暂未作为标准接口添加至 API 层。
     * 对于未实现的方法，接口响应 Unsupport 错误码
     * @param method 方法名
     * @param args
     */
    callExtra(method: string | keyof IExtraMethod, ...args: any[]): Promise<IAsyncRes<unknown>>;
    /**
     * 删除所有会话
    */
    clearConversations(conversationTypes?: ConversationType[], tag?: string): Promise<ErrorCode>;
    /**
     * 设置用户连接状态监听器
    */
    setUserStatusListener(config: {
        userIds: string[];
    }, listener: Function): void;
    /**
     * 添加用户黑名单
    */
    addToBlacklist(userId: string): Promise<ErrorCode>;
    /**
     * 将指定用户移除黑名单
    */
    removeFromBlacklist(userId: string): Promise<ErrorCode>;
    /**
     * 获取黑名单列表
    */
    getBlacklist(): Promise<IAsyncRes<string[]>>;
    /**
     * 获取指定人员在黑名单中的状态
    */
    getBlacklistStatus(userId: string): Promise<IAsyncRes<string>>;
    /**
     * 向本地插入一条消息，不发送到服务器
    */
    insertMessage(conversationType: ConversationType, targetId: string, insertOptions: IInsertMsgOptions): Promise<IAsyncRes<IReceivedMessage>>;
    /**
     * 删除本地消息
    */
    deleteMessages(timestamp: number[]): Promise<ErrorCode>;
    /**
     * 从本地消息数据库中删除某一会话指定时间之前的消息数据
    */
    deleteMessagesByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, cleanSpace: boolean, channelId?: string): Promise<ErrorCode>;
    /**
     * 清空会话下历史消息
    */
    clearMessages(conversationType: ConversationType, targetId: string, channelId?: string): Promise<ErrorCode>;
    /**
     * 获取本地消息
    */
    getMessage(messageId: number): Promise<IAsyncRes<IReceivedMessage>>;
    /**
     * 设置消息内容
    */
    setMessageContent(messageId: number, content: any, messageType: string): Promise<ErrorCode>;
    /**
     * 设置消息搜索字段
    */
    setMessageSearchField(messageId: number, content: any, searchFiles: string): Promise<ErrorCode>;
    /**
     * 设置消息发送状态
    */
    setMessageSentStatus(messageId: number, sentStatus: number): Promise<ErrorCode>;
    /**
    * 设置消息接收状态
    */
    setMessageReceivedStatus(messageId: number, receivedStatus: number): Promise<ErrorCode>;
    /**
     * 设置当前用户在线状态
    */
    setUserStatus(status: number): Promise<ErrorCode>;
    /**
     * 订阅用户在线状态
    */
    subscribeUserStatus(userIds: string[]): Promise<ErrorCode>;
    /**
     * 获取用户在线状态
    */
    getUserStatus(userId: string): Promise<IAsyncRes<{
        status: string;
    }>>;
    searchConversationByContent(keyword: string, customMessageTypes?: string[], channelId?: string, conversationTypes?: ConversationType[]): Promise<IAsyncRes<IReceivedConversation[]>>;
    searchMessageByContent(conversationType: ConversationType, targetId: string, keyword: string, timestamp: number, count: number, total: number, channelId?: string): Promise<IAsyncRes<{
        messages: IReceivedMessage[];
        count: number;
    }>>;
    getUnreadMentionedMessages(conversationType: ConversationType, targetId: string, channelId?: string): IReceivedMessage[];
    clearUnreadCountByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, channelId?: string): Promise<ErrorCode>;
    /**
     * 获取会话免打扰状态
    */
    getConversationNotificationStatus(conversationType: ConversationType, targetId: string, channelId?: string): Promise<IAsyncRes<NotificationStatus>>;
    getRemoteHistoryMessages(conversationType: ConversationType, targetId: string, timestamp: number, count: number, order: 0 | 1, channelId: string): Promise<IAsyncRes<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>>;
    /**
     * 加入房间
     * @param roomId
     * @param mode 房间模式：直播 or 会议
     * @param mediaType 直播房间模式下的媒体资源类型
     */
    joinRTCRoom(roomId: string, mode: RTCMode, mediaType?: number, joinType?: RTCJoinType): Promise<IAsyncRes<IJoinRTCRoomData>>;
    quitRTCRoom(roomId: string): Promise<ErrorCode>;
    rtcPing(roomId: string, mode: number, mediaType?: number): Promise<ErrorCode>;
    getRTCRoomInfo(roomId: string): Promise<IAsyncRes<IRTCRoomInfo>>;
    getRTCUserInfoList(roomId: string): Promise<IAsyncRes<IRTCUsers>>;
    getRTCUserInfo(roomId: string): IPromiseResult<unknown>;
    setRTCUserInfo(roomId: string, key: string, value: string): Promise<ErrorCode>;
    removeRTCUserInfo(roomId: string, keys: string[]): Promise<ErrorCode>;
    setRTCData(roomId: string, key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    setRTCTotalRes(roomId: string, message: {
        name: string;
        content: string;
    }, valueInfo: string, objectName: string, mcuValInfo?: string): Promise<ErrorCode>;
    setRTCCDNUris(roomId: string, objectName: string, CDNUris: string): Promise<ErrorCode>;
    getRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType): Promise<IAsyncRes<KVString>>;
    removeRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    setRTCOutData(roomId: string, rtcData: unknown, type: number, message: unknown): Promise<ErrorCode>;
    getRTCOutData(roomId: string, userIds: string[]): IPromiseResult<unknown>;
    getRTCToken(roomId: string, mode: number, broadcastType?: number): Promise<IAsyncRes<IRtcTokenData>>;
    setRTCState(roomId: string, report: string): Promise<ErrorCode>;
    getRTCUserList(roomId: string): IPromiseResult<IRTCUsers>;
    /**
     * 直播观众加房间
     */
    joinLivingRoomAsAudience(roomId: string, mode: RTCMode, broadcastType?: number): Promise<IAsyncRes<{
        token: string;
        kvEntries: IServerRTCRoomEntry[];
    }>>;
    /**
     * 直播观众退出房间
     */
    quitLivingRoomAsAudience(roomId: string): Promise<ErrorCode>;
    /**
     * 直播身份切换
     */
    rtcIdentityChange(roomId: string, changeType: RTCIdentityChangeType, broadcastType?: number): Promise<IAsyncRes<IJoinRTCRoomData>>;
    /**
     * 获取加入 RTC 房间的用户信息（当前仅能查自己的）
     */
    getRTCJoinedUserInfo(userId: string): Promise<IAsyncRes<IRTCJoinedInfo[]>>;
}

/**
 * engine 基本接口定义，用于约束 Electron 下主进程、渲染进程、JSEngine 的编码一致性
 */
interface IEngine {
    /**
     * 建立连接
     * @param token
     * @param naviInfo
     */
    connect(token: string, naviInfo: INaviInfo, versionInfo: string): Promise<ErrorCode>;
    /**
     * 上报版本信息
     * @param version
     */
    reportSDKInfo(version: {
        [name: string]: string;
    }): void;
    /**
     * 连接时间
     */
    getConnectedTime(): number;
    /**
     * 调用非标准方法。所谓非标准方法，是为某些特定需求或产品添加，暂未作为标准接口添加至 API 层。
     * 对于未实现的方法，接口响应 Unsupport 错误码
     * @param method
     * @param args
     */
    callExtra(method: string | keyof IExtraMethod, ...args: any[]): Promise<IAsyncRes<unknown>>;
    /**
     * 获取历史消息
     * @param conversationType
     * @param targetId
     * @param timestamp
     * @param count
     * @param order
     */
    getHistoryMessage(conversationType: ConversationType, targetId: string, 
    /**
     * 拉取时间戳，值为 `0` 表示从当前时间拉取
     */
    timestamp: number, 
    /**
     * 获取条数, 有效值 `1` - `20`
     */
    count: number, 
    /**
     * @description
     * 1. `0` 表示升序，获取消息发送时间比传入 `sentTime` 小 的消息
     * 2. `1` 表示降序，获取消息发送时间比传入 `sentTime` 大 的消息
     */
    order: 0 | 1, 
    /**
     * 会话的业务标识
    */
    channelId: string, 
    /**
     * 消息类型
     */
    objectName: string): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    /**
     * 删除历史消息 通过 messageUId
    */
    deleteRemoteMessage(conversationType: ConversationType, targetId: string, 
    /**
     * @description
     * message 中 messageUId、setTime、messageDirection 为必须参数
    */
    messages: {
        messageUId: string;
        sentTime: number;
        messageDirection: MessageDirection;
    }[], 
    /**
     * 会话的业务标识
    */
    channelId: string): Promise<ErrorCode>;
    recallMsg(conversationType: ConversationType, targetId: string, messageUId: string, sentTime: number, recallMsgOptions: IRecallMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 删除历史消息 通过 时间戳
     * @param timestamp 小于等于传入时间戳的消息均删除
    */
    deleteRemoteMessageByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, 
    /**
     * 会话的业务标识
    */
    channelId: string): Promise<ErrorCode>;
    /**
     * 获取会话列表
     * @param count 指定获取数量, 不传则获取全部会话列表，默认 `300`
     */
    getConversationList(
    /**
     * 拉取数量, 有效值 0 - 1000, 默认 300
     */
    count: number, 
    /**
     * 会话类型
     * @todo 待确认是否生效
     */
    conversationType?: ConversationType, 
    /**
     * 起始时间
    */
    startTime?: number, 
    /**
     * 获取顺序
    */
    order?: 0 | 1, 
    /**
     * 会话的业务标识
    */
    channelId?: string): IPromiseResult<IReceivedConversation[]>;
    /**
     * 获取指定会话
    */
    getConversation(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<IReceivedConversation | null>;
    /**
     * 删除会话
     * @description 该删除操作会删除服务器端存储的会话数据
     * @param conversationType
     * @param targetId
     */
    removeConversation(conversationType: ConversationType, targetId: string, channelId: string): Promise<ErrorCode>;
    /**
     * 获取所有会话未读数
     * @param channelId 多组织 Id
     * @param conversationTypes
     * @param includeMuted 包含已设置免打扰的会话
     */
    getAllConversationUnreadCount(channelId: string, conversationTypes: ConversationType[], includeMuted: boolean): IPromiseResult<number>;
    /**
     * 获取指定会话未读数
     */
    getConversationUnreadCount(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<number>;
    /**
     * 清除指定会话未读数
     */
    clearConversationUnreadCount(conversationType: ConversationType, targetId: string, channelId: string): Promise<ErrorCode>;
    /**
     * 获取第一个未读消息
     */
    getFirstUnreadMessage(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<IReceivedMessage | null>;
    /**
     * 设置/保存指定会话消息草稿
     * @draft 草稿内容
     */
    saveConversationMessageDraft(conversationType: ConversationType, targetId: string, draft: string): Promise<ErrorCode>;
    /**
     * 获取指定会话消息草稿
     */
    getConversationMessageDraft(conversationType: ConversationType, targetId: string): IPromiseResult<string>;
    /**
     * 清除指定会话消息草稿
     */
    clearConversationMessageDraft(conversationType: ConversationType, targetId: string): Promise<ErrorCode>;
    /**
     * 从服务端拉取会话状态
     */
    pullConversationStatus(timestamp: number): Promise<IAsyncRes<IServerConversationStatus[]>>;
    /**
     * 批量设置会话 置顶、免打扰
     */
    batchSetConversationStatus(statusList: ISetConversationStatusOptions[]): Promise<ErrorCode>;
    sendMessage(conversationType: ConversationType, targetId: string, options: ISendMsgOptions, onBefore?: (messageId: number) => void): IPromiseResult<IReceivedMessage>;
    /**
     * 断开连接
     */
    disconnect(): void;
    /**
     * 拉取用户级配置数据
     */
    pullUserSettings(version: number): IPromiseResult<IServerUserSetting>;
    /**
     * 消息注册
     * @description
     * 消息注册需在应用初始化完成前进行，否则在搭配 C++ 协议栈使用时，
     * 本端发出的消息将不默认作为未知消息处理，不存储、不计数
     * @param objectName 消息类型，如：RC:TxtMsg
     * @param isPersited 是否存储
     * @param isCounted 是否技术
     * @param searchProps 搜索字段，只在搭配协议栈使用时有效
     */
    registerMessageType(objectName: string, isPersited: boolean, isCounted: boolean, searchProps: string[]): void;
    /**
     * 加入聊天室
     * @param count 拉取消息数量
    */
    joinChatroom(chatroomId: string, count: number): Promise<ErrorCode>;
    /**
     * 加入已存在的聊天室
     * @param count 拉取消息数量
    */
    joinExistChatroom(chatroomId: string, count: number): Promise<ErrorCode>;
    /**
     * 退出聊天室
    */
    quitChatroom(chatroomId: string): Promise<ErrorCode>;
    /**
     * 获取聊天室信息
     * @param count 获取人数, 范围 0 - 20
     * @param order 排序方式, 1 正序, 2 倒序
    */
    getChatroomInfo(chatroomId: string, count: number, order: number): IPromiseResult<IChatroomInfo>;
    /**
     * 获取聊天室历史消息
    */
    getChatroomHistoryMessages(chatroomId: string, timestamp: number, count: number, order: number): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    /**
     * 设置聊天室属性
    */
    setChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
     * 批量设置聊天室属性
     */
    setChatroomEntries(chatroomId: string, entry: IChrmKVEntries): Promise<{
        code: ErrorCode;
        data?: any;
    }>;
    /**
     * 强制设置聊天室属性
    */
    forceSetChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
     * 删除聊天室属性
    */
    removeChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
     * 批量删除聊天室属性
     */
    removeChatroomEntries(chatroomId: string, entries: IChrmKVEntries): Promise<{
        code: ErrorCode;
        data?: any;
    }>;
    /**
     * 强制删除聊天室属性
    */
    forceRemoveChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
      * 获取聊天室 key 对应 value
    */
    getChatroomEntry(chatroomId: string, key: string): IPromiseResult<string | null>;
    /**
      * 获取聊天室所有 key value
    */
    getAllChatroomEntry(chatroomId: string): IPromiseResult<{
        [key: string]: string;
    }>;
    /**
     * 获取上传认证信息
     * @description
     * 若不传 fileName 百度上传认证字段（bosToken、bosDate、path）均返回 null
    */
    getFileToken(fileType: FileType, fileName?: string, httpMethod?: string, queryUriString?: string): Promise<IAsyncRes<IUploadAuth>>;
    /**
     * 获取文件上传后下载地址
    */
    getFileUrl(fileType: FileType, uploadMethod: UploadMethod, fileName?: string, originName?: string): IPromiseResult<{
        downloadUrl: string;
    }>;
    /**
     * 创建标签
     * @param tag 标签
    */
    createTag(tag: ITagParam): IPromiseResult<IAsyncRes>;
    /**
     * 删除标签
     * @param tagId 标签id
    */
    removeTag(tagId: string): IPromiseResult<IAsyncRes>;
    /**
     * 编辑标签
     * @param tag 标签
    */
    updateTag(tag: ITagParam): IPromiseResult<IAsyncRes>;
    /**
     * 获取标签列表
     */
    getTagList(): IPromiseResult<Array<ITagInfo>>;
    /**
     * 添加会话到标签（给多个会话增加标签）
     * @param tagId 标签id
     * @param conversations 要添加的会话列表
     */
    addTagForConversations(tagId: string, conversations: IConversationOption[]): IPromiseResult<IAsyncRes>;
    /**
     * 删除标签中的会话(从多个会话中批量删除指定标签)
     * @param tagId 标签id
     * @param conversations 要删除的会话列表
     */
    removeTagForConversations(tagId: string, conversations: IConversationOption[]): IPromiseResult<IAsyncRes>;
    /**
     * 删除会话中的标签(从单一会话中批量删除标签)
     * @param conversationType 会话类型
     * @param targetId 会话id
     * @param tagIds 要删除的标签列表
     */
    removeTagsForConversation(conversation: IConversationOption, tagIds: string[]): IPromiseResult<IAsyncRes>;
    /**
     * 获取标签下的会话列表
     * @param tagId 标签id
     */
    getConversationListByTag(tagId: string, startTime: number, count?: number, channelId?: string): IPromiseResult<IReceivedConversationByTag[]>;
    /**
     * 获取标签下的未读消息数
     * @param tagId 标签id
     * @param containMuted 是否包含免打扰会话
     */
    getUnreadCountByTag(tagId: string, containMuted: boolean): IPromiseResult<number>;
    /**
     * 设置标签中会话置顶
     * @param conversation 会话
     */
    setConversationStatusInTag(tagId: string, conversation: IConversationOption, status: ITagStatus): IPromiseResult<IAsyncRes>;
    /**
     * 获取会话里的标签
     * @param config
     */
    getTagsForConversation(conversation: IConversationOption): IPromiseResult<IConversationTag[]>;
    /**
     * 发送群组消息已读回执
     * 导航下发已读回执开关为 true 时调用
     */
    sendReadReceiptMessage(targetId: string, messageUIds: string[], channelId?: string): Promise<IAsyncRes>;
    /**
     * 获取群组消息已读列表
     */
    getMessageReader(targetId: string, messageUId: string, channelId?: string): IPromiseResult<IMessageReaderResponse>;
    /**
     * 获取服务器时间
     */
    getServerTime(): number;
    /**
     * 获取设备ID
     */
    getDeviceId(): string;
    /**
     * 获取当前 userId
     */
    getCurrentUserId(): string;
    /**
     * 设置用户在线状态监听器
    */
    setUserStatusListener(config: {
        userIds: string[];
    }, listener: Function): void;
    /**
     * 设置当前用户在线状态
    */
    setUserStatus(status: number): Promise<ErrorCode>;
    /**
     * 订阅用户在线状态
    */
    subscribeUserStatus(userIds: string[]): Promise<ErrorCode>;
    /**
     * 获取用户状态
    */
    getUserStatus(userId: string): IPromiseResult<{
        status: string;
    }>;
    /**
     * 清空所有会话
    */
    clearConversations(conversationTypes?: ConversationType[], channelId?: string): Promise<ErrorCode>;
    /**
     * 加入黑名单
    */
    addToBlacklist(userId: string): Promise<ErrorCode>;
    /**
      * 将指定用户移除黑名单
    */
    removeFromBlacklist(userId: string): Promise<ErrorCode>;
    /**
      * 获取黑名单列表
    */
    getBlacklist(): IPromiseResult<string[]>;
    /**
      * 获取指定人员在黑名单中的状态
    */
    getBlacklistStatus(userId: string): IPromiseResult<string>;
    /**
     * 向本地插入一条消息，不发送到服务器
    */
    insertMessage(conversationType: ConversationType, targetId: string, insertOptions: IInsertMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 删除本地消息
    */
    deleteMessages(timestamps: number[]): Promise<ErrorCode>;
    /**
     * 通过时间戳删除本地消息
    */
    deleteMessagesByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, cleanSpace: boolean, channelId: string): Promise<ErrorCode>;
    /**
     * 清空会话下历史消息
    */
    clearMessages(conversationType: ConversationType, targetId: string, channelId: string): Promise<ErrorCode>;
    /**
     * 获取消息
    */
    getMessage(messageId: number): IPromiseResult<IReceivedMessage>;
    /**
     * 设置消息内容
    */
    setMessageContent(messageId: number, content: any, messageType: string): Promise<ErrorCode>;
    /**
     * 设置消息搜索字段
    */
    setMessageSearchField(messageId: number, content: any, searchFiles: string): Promise<ErrorCode>;
    /**
     * 通过关键字搜索会话
    */
    searchConversationByContent(keyword: string, customMessageTypes: string[], channelId: string, conversationTypes?: ConversationType[]): IPromiseResult<IReceivedConversation[]>;
    /**
     * 按内容搜索会话内的消息
    */
    searchMessageByContent(conversationType: ConversationType, targetId: string, keyword: string, timestamp: number, count: number, total: number, channelId: string): IPromiseResult<{
        messages: IReceivedMessage[];
        count: number;
    }>;
    /**
     * 获取会话下所有未读的 @ 消息
    */
    getUnreadMentionedMessages(conversationType: ConversationType, targetId: string, channelId: string): IReceivedMessage[];
    /**
     * 设置消息发送状态
    */
    setMessageSentStatus(messageId: number, sentStatus: number): Promise<ErrorCode>;
    /**
     * 设置消息接收状态
    */
    setMessageReceivedStatus(messageId: number, receivedStatus: number): Promise<ErrorCode>;
    /**
     * 删除时间戳前的未读数
    */
    clearUnreadCountByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, channelId: string): Promise<ErrorCode>;
    /**
     * 获取会话免打扰状态
    */
    getConversationNotificationStatus(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<NotificationStatus>;
    /**
     * 协议栈获取远端历史消息
    */
    getRemoteHistoryMessages(conversationType: ConversationType, targetId: string, timestamp: number, count: number, order: 0 | 1, channelId: string): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    joinRTCRoom(roomId: string, mode: RTCMode, broadcastType?: number): IPromiseResult<IJoinRTCRoomData>;
    quitRTCRoom(roomId: string): Promise<ErrorCode>;
    rtcPing(roomId: string, mode: number, broadcastType?: number): Promise<ErrorCode>;
    getRTCRoomInfo(roomId: string): IPromiseResult<IRTCRoomInfo>;
    getRTCUserInfoList(roomId: string): IPromiseResult<IRTCUsers>;
    getRTCUserInfo(roomId: string): IPromiseResult<unknown>;
    setRTCUserInfo(roomId: string, key: string, value: string): Promise<ErrorCode>;
    removeRTCUserInfo(roomId: string, keys: string[]): Promise<ErrorCode>;
    setRTCData(roomId: string, key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    /**
     * 全量订阅资源修改
     * @param roomId 房间 Id
     * @param message 向前兼容的消息内容
     * @param valueInfo 全量资源数据
     * @param objectName 全量 URI 消息名
     */
    setRTCTotalRes(roomId: string, message: {
        name: string;
        content: string;
    }, valueInfo: string, objectName: string, mcuValInfo: string): Promise<ErrorCode>;
    getRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType): IPromiseResult<KVString>;
    removeRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    setRTCOutData(roomId: string, rtcData: unknown, type: number, message: unknown): Promise<ErrorCode>;
    getRTCOutData(roomId: string, userIds: string[]): IPromiseResult<unknown>;
    getRTCToken(roomId: string, mode: number, broadcastType?: number): IPromiseResult<IRtcTokenData>;
    setRTCState(roomId: string, reportId: string): Promise<ErrorCode>;
    getRTCUserList(roomId: string): IPromiseResult<IRTCUsers>;
    setRTCCDNUris(roomId: string, objectName: string, CDNUris: string): Promise<ErrorCode>;
}

interface IExpansionMsgContent {
    /**
     * 消息扩展的对象
    */
    put?: {
        [key: string]: string;
    };
    /**
     * 删除的 keys
    */
    del?: string[];
    /**
     * messageUId
    */
    mid: string;
    /**
     * 是否删除所有, 有效值：0、1 . ( 后续如有需要, API Layer 层可使用)
    */
    removeAll?: number;
}

declare class RTCPluginContext extends PluginContext {
    /**
     * 获取当前的导航数据
     */
    getNaviInfo(): INaviInfo | null;
    /**
     * 加入 RTC 房间
     * @todo 需确认 `broadcastType` 参数的作用与有效值
     * @param roomId
     * @param mode 房间模式：直播 or 会议
     * @param broadcastType
     */
    joinRTCRoom(roomId: string, mode: RTCMode, broadcastType?: number, joinType?: RTCJoinType): IPromiseResult<IJoinRTCRoomData>;
    quitRTCRoom(roomId: string): Promise<ErrorCode>;
    rtcPing(roomId: string, mode: number, broadcastType?: number): Promise<ErrorCode>;
    getRTCRoomInfo(roomId: string): IPromiseResult<IRTCRoomInfo>;
    getRTCUserInfoList(roomId: string): IPromiseResult<IRTCUsers>;
    getRTCUserInfo(roomId: string): IPromiseResult<unknown>;
    setRTCUserInfo(roomId: string, key: string, value: string): Promise<ErrorCode>;
    removeRTCUserInfo(roomId: string, keys: string[]): Promise<ErrorCode>;
    setRTCData(roomId: string, key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: any): Promise<ErrorCode>;
    /**
     * @param - roomId
     * @param - message 向前兼容的消息数据，以兼容旧版本 SDK，即增量数据，如：
     * ```
     * JSON.stringify({
     *  name: 'RCRTC:PublishResource',
     *  content: {
     *  }
     * })
     * ```
     * @param - valueInfo 全量资源数据
     * @param - 全量 URI 消息名，即 `RCRTC:TotalContentResources`
     */
    setRTCTotalRes(roomId: string, 
    /**
     * 向旧版本 RTCLib 兼容的消息数据
     */
    message: {
        /**
         * 消息名称，如 'RCRTC:PublishResource'
         */
        name: string;
        /**
         * 消息内容，是一个 JSON 字符串，包含 uris, ignore 两个属性
         */
        content: string;
    }, valueInfo: string, objectName: string, 
    /**
     * mcu 合流发布内容，是一个 JSON 字符串，解析类型为 {mediaType: number, msid: string, uri: string}[]
     */
    mcuValInfo?: string): Promise<ErrorCode>;
    /**
     * 设置 cdn_uris 扩散
     * @param objectName 全量 URI 消息名，即 `RCRTC:TotalContentResources`
     * @param CDNUris cdn_uris 扩散字段
     * {
        "broadcast":0,
        "fps":25,
        "h":640,
        "pull_safe":true,
        "push_mode":1,
        "url":"https://rtc-media-api-service-ucbj2-01.rongcloud.net/api/rtc/cdn/player",
        "w":360,
        "enableInnerCDN":true
      }[]
     */
    setRTCCDNUris(roomId: string, objectName: string, CDNUris: string): Promise<ErrorCode>;
    getRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType): IPromiseResult<KVString>;
    removeRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    setRTCOutData(roomId: string, rtcData: unknown, type: number, message: unknown): Promise<ErrorCode>;
    getRTCOutData(roomId: string, userIds: string[]): IPromiseResult<unknown>;
    getRTCToken(roomId: string, mode: number, broadcastType?: number): IPromiseResult<IRtcTokenData>;
    setRTCState(roomId: string, report: string): Promise<ErrorCode>;
    getRTCUserList(roomId: string): IPromiseResult<IRTCUsers>;
    /**
     * 直播观众加房间
     */
    joinLivingRoomAsAudience(roomId: string, mode: RTCMode, broadcastType?: number): IPromiseResult<{
        token: string;
        kvEntries: IServerRTCRoomEntry[];
    }>;
    /**
     * 直播观众退出房间
     */
    quitLivingRoomAsAudience(roomId: string): Promise<ErrorCode>;
    /**
     * 直播身份切换
     */
    rtcIdentityChange(roomId: string, changeType: RTCIdentityChangeType, broadcastType?: number): IPromiseResult<IJoinRTCRoomData>;
}

declare abstract class ANavi {
    protected readonly _runtime: IRuntime;
    protected readonly _options: IAPIContextOption;
    protected readonly _apiVersion: string;
    protected readonly _appkey: string;
    protected _naviInfo: INaviInfo | null;
    constructor(_runtime: IRuntime, _options: IAPIContextOption);
    /**
     * @param uris
     * @param appkey
     * @param token
     */
    protected abstract _reqNavi(uris: string[], appkey: string, token: string, checkCA?: boolean): Promise<INaviInfo | null>;
    /**
     * 获取导航数据
     * @param token
     * @param dynamicUris token 携带的动态导航地址
     * @param force 是否强制重新获取并清空缓存数据
     */
    getInfo(token: string, dynamicUris: string[], force: boolean, checkCA?: boolean): Promise<INaviInfo | null>;
    protected setNaviInfo2Cache(token: string, naviInfo: INaviInfo): void;
    getInfoFromCache(token: string): INaviInfo | null;
    /**
     * 清空导航数据：内存数据、缓存数据
     */
    private _clear;
}

interface IEngineWatcher {
    /**
     * @param message 消息
     * @param leftCount 参数废弃，值始终为 undefined
     * @param hasMore 消息是否收取结束，需与协议栈配合使用
    */
    message: (message: IReceivedMessage, leftCount?: number, hasMore?: boolean) => void;
    status: (status: ConnectionStatus) => void;
    chatroom: (event: IChatroomListenerData) => void;
    conversation: (event: any) => void;
    expansion: (event: IExpansionListenerData) => void;
    tag: () => void;
    conversationTag: () => void;
    /**
     * RTC 数据变更
     */
    onRTCDataChange: (data: IServerRTCRoomEntry[], roomId?: string) => void;
    pullFinished: () => void;
}
/**
 * 引擎定义
 */
declare abstract class AEngine implements IEngine {
    readonly runtime: IRuntime;
    protected readonly _watcher: IEngineWatcher;
    protected readonly _options: IAPIContextOption;
    /**
     * 当前用户 Id
     */
    currentUserId: string;
    /**
     * 连接时间
    */
    abstract getConnectedTime(): number;
    readonly navi: ANavi;
    protected readonly _appkey: string;
    protected readonly _apiVer: string;
    /**
     * 引擎初始化
     * @param _appkey
     */
    constructor(runtime: IRuntime, _watcher: IEngineWatcher, _options: IAPIContextOption);
    protected abstract _createNavi(): ANavi;
    /**
     * 调用非标准方法。所谓非标准方法，是为某些特定需求或产品添加，暂未作为标准接口添加至 API 层。
     * 对于未实现的方法，接口响应 Unsupport 错误码
     * @param method
     * @param args
     */
    abstract callExtra(method: string | keyof IExtraMethod, ...args: any[]): Promise<IAsyncRes<unknown>>;
    /**
     * 建立连接
     * @param token
     * @param naviInfo
     */
    abstract connect(token: string, naviInfo: INaviInfo): Promise<ErrorCode>;
    /**
     * 发送SDK版本
     * @param versionInfo
     */
    abstract reportSDKInfo(versionInfo: {
        [name: string]: string;
    }): void;
    /**
     * 获取历史消息
     * @param conversationType
     * @param targetId
     * @param timestamp
     * @param count
     * @param order
     */
    abstract getHistoryMessage(conversationType: ConversationType, targetId: string, 
    /**
     * 拉取时间戳，值为 `0` 表示从当前时间拉取
     */
    timestamp: number, 
    /**
     * 获取条数, 有效值 `1` - `20`
     */
    count: number, 
    /**
     * @description
     * 1. `0` 表示升序，获取消息发送时间比传入 `sentTime` 小 的消息
     * 2. `1` 表示降序，获取消息发送时间比传入 `sentTime` 大 的消息
     */
    order: 0 | 1, 
    /**
     * 会话的业务标识
    */
    channelId: string, 
    /**
     * 消息类型
     */
    objectName: string): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    /**
     * 删除历史消息 通过 messageUId
    */
    abstract deleteRemoteMessage(conversationType: ConversationType, targetId: string, 
    /**
     * @description
     * message 中 messageUId、setTime、messageDirection 为必须参数
    */
    messages: {
        messageUId: string;
        sentTime: number;
        messageDirection: MessageDirection;
    }[], 
    /**
     * 会话的业务标识
    */
    channelId: string): Promise<ErrorCode>;
    abstract recallMsg(conversationType: ConversationType, targetId: string, messageUId: string, sentTime: number, recallMsgOptions: IRecallMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 删除历史消息 通过 时间戳
     * @param timestamp 小于等于传入时间戳的消息均删除
    */
    abstract deleteRemoteMessageByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, 
    /**
     * 会话的业务标识
    */
    channelId: string): Promise<ErrorCode>;
    /**
     * 获取会话列表
     * @param count 指定获取数量, 不传则获取全部会话列表，默认 `300`
     */
    abstract getConversationList(
    /**
     * 拉取数量, 有效值 0 - 1000, 默认 300
     */
    count: number, 
    /**
     * 会话类型
     * @todo 待确认是否生效
     */
    conversationType?: ConversationType, 
    /**
     * 起始时间
    */
    startTime?: number, 
    /**
     * 获取顺序
    */
    order?: 0 | 1, 
    /**
     * 会话的业务标识
    */
    channelId?: string): IPromiseResult<IReceivedConversation[]>;
    /**
     * 获取指定会话
    */
    abstract getConversation(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<IReceivedConversation | null>;
    /**
     * 删除会话
     * @description 该删除操作会删除服务器端存储的会话数据
     * @param conversationType
     * @param targetId
     */
    abstract removeConversation(conversationType: ConversationType, targetId: string, channelId: string): Promise<ErrorCode>;
    /**
     * 获取所有会话未读数
     * @param channelId 多组织 Id
     * @param conversationTypes
     * @param includeMuted 包含已设置免打扰的会话
     */
    abstract getAllConversationUnreadCount(channelId: string, conversationTypes: ConversationType[], includeMuted: boolean): IPromiseResult<number>;
    /**
     * 获取指定会话未读数
     */
    abstract getConversationUnreadCount(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<number>;
    /**
     * 清除指定会话未读数
     */
    abstract clearConversationUnreadCount(conversationType: ConversationType, targetId: string, channelId: string): Promise<ErrorCode>;
    /**
     * 获取第一个未读消息
     */
    abstract getFirstUnreadMessage(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<IReceivedMessage | null>;
    /**
     * 设置/保存指定会话消息草稿
     * @draft 草稿内容
     */
    abstract saveConversationMessageDraft(conversationType: ConversationType, targetId: string, draft: string): Promise<ErrorCode>;
    /**
     * 获取指定会话消息草稿
     */
    abstract getConversationMessageDraft(conversationType: ConversationType, targetId: string): IPromiseResult<string>;
    /**
     * 清除指定会话消息草稿
     */
    abstract clearConversationMessageDraft(conversationType: ConversationType, targetId: string): Promise<ErrorCode>;
    /**
     * 从服务端拉取会话状态
     */
    abstract pullConversationStatus(timestamp: number): Promise<IAsyncRes<IServerConversationStatus[]>>;
    /**
     * 批量设置会话 置顶、免打扰
     */
    abstract batchSetConversationStatus(statusList: ISetConversationStatusOptions[]): Promise<ErrorCode>;
    abstract sendMessage(conversationType: ConversationType, targetId: string, options: ISendMsgOptions, 
    /**
     * c++ 消息写库后存在自增 Id，必要时需要向业务层暴露，JSEngine 无需实现
     */
    onBefore?: (messageId: number) => void): IPromiseResult<IReceivedMessage>;
    /**
     * 发送群组消息已读回执
     * 导航下发已读回执开关为 true 时调用
     * @param targetId
     * @param messageUIds
     */
    abstract sendReadReceiptMessage(targetId: string, messageUIds: string[], channelId?: string): Promise<IAsyncRes>;
    /**
     * 获取群组消息已读列表
     * @param targetId
     * @param messageUIds
     */
    abstract getMessageReader(targetId: string, messageUId: string, channelId?: string): IPromiseResult<IMessageReaderResponse>;
    /**
     * 断开连接
     */
    abstract disconnect(): void;
    /**
     * 拉取用户级配置数据
     */
    abstract pullUserSettings(version: number): IPromiseResult<IServerUserSetting>;
    /**
     * 消息注册
     * @description
     * 消息注册需在应用初始化完成前进行，否则在搭配 C++ 协议栈使用时，
     * 本端发出的消息将不默认作为未知消息处理，不存储、不计数
     * @param objectName 消息类型，如：RC:TxtMsg
     * @param isPersited 是否存储
     * @param isCounted 是否技术
     * @param searchProps 搜索字段，只在搭配协议栈使用时有效
     */
    abstract registerMessageType(objectName: string, isPersited: boolean, isCounted: boolean, searchProps: string[]): void;
    /**
     * 加入聊天室
     * @param count 拉取消息数量
    */
    abstract joinChatroom(chatroomId: string, count: number): Promise<ErrorCode>;
    /**
     * 加入已存在的聊天室
     * @param count 拉取消息数量
    */
    abstract joinExistChatroom(chatroomId: string, count: number): Promise<ErrorCode>;
    /**
     * 退出聊天室
    */
    abstract quitChatroom(chatroomId: string): Promise<ErrorCode>;
    /**
     * 获取聊天室信息
     * @param count 获取人数, 范围 0 - 20
     * @param order 排序方式, 1 正序, 2 倒序
    */
    abstract getChatroomInfo(chatroomId: string, count: number, order: number): IPromiseResult<IChatroomInfo>;
    /**
     * 获取聊天室历史消息
    */
    abstract getChatroomHistoryMessages(chatroomId: string, timestamp: number, count: number, order: number): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    /**
     * 设置聊天室属性
    */
    abstract setChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
     * 批量设置聊天室属性
     */
    abstract setChatroomEntries(chatroomId: string, entry: IChrmKVEntries): Promise<{
        code: ErrorCode;
        data?: any;
    }>;
    /**
     * 强制设置聊天室属性
    */
    abstract forceSetChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
     * 删除聊天室属性
    */
    abstract removeChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
     * 批量删除聊天室属性
     */
    abstract removeChatroomEntries(chatroomId: string, entry: IChrmKVEntries): Promise<{
        code: ErrorCode;
        data?: any;
    }>;
    /**
     * 强制删除聊天室属性
    */
    abstract forceRemoveChatroomEntry(chatroomId: string, entry: IChrmKVEntry): Promise<ErrorCode>;
    /**
      * 获取聊天室 key 对应 value
    */
    abstract getChatroomEntry(chatroomId: string, key: string): IPromiseResult<string | null>;
    /**
      * 获取聊天室所有 key value
    */
    abstract getAllChatroomEntry(chatroomId: string): IPromiseResult<{
        [key: string]: string;
    }>;
    /**
     * 获取存储服务鉴权信息
     * @param fileType 文件类型
     * @param fileName 文件名称
     * @param httpMethod STC 分段上传时的必填参数，有效值为 PUT | POST
     * @param queryString STC 分段上传时的查询字符串
     * @description
     * `httpMethod` 与 `queryString` 为 STC S3 分段上传时的专属参数，STC 分段上传包含三个过程：
     * 1. 开始分段前调用，此时 `httpMethod` 值应为 `POST`， `queryString` 值为 `uploads`
     * 2. 上传请求前调用，此时 `httpMethod` 值应为 `PUT`，`queryString` 值为 `partNumber={partamNumer}&uploadId={uploadId}`
     * 3. 上传结束前调用，此时 `httpMethod` 值应为 `POST`，`queryString` 值为 `uploadId={uploadId}`
     * @returns
     */
    abstract getFileToken(fileType: FileType, fileName?: string, httpMethod?: string, queryString?: string): Promise<IAsyncRes<IUploadAuth>>;
    /**
     * 获取文件的下载地址
     * @param fileType 文件类型
     * @param serverType 使用的存储服务标识
     * @param fileName 文件名
     * @param saveName 下载后的存储文件名
     * @returns
     */
    abstract getFileUrl(fileType: FileType, serverType: UploadMethod, fileName?: string, saveName?: string): IPromiseResult<{
        downloadUrl: string;
    }>;
    /**
     * 创建标签
     * @param tag 标签
    */
    abstract createTag(tag: ITagParam): IPromiseResult<IAsyncRes>;
    /**
     * 删除标签
     * @param tagId 标签id
    */
    abstract removeTag(tagId: string): IPromiseResult<IAsyncRes>;
    /**
     * 编辑标签
     * @param tag 标签
    */
    abstract updateTag(tag: ITagParam): IPromiseResult<IAsyncRes>;
    /**
     * 获取标签列表
     */
    abstract getTagList(): IPromiseResult<Array<ITagInfo>>;
    /**
     * 添加会话到标签（给多个会话增加标签）
     * @param tagId 标签id
     * @param conversations 要添加的会话列表
     */
    abstract addTagForConversations(tagId: string, conversations: IConversationOption[]): IPromiseResult<IAsyncRes>;
    /**
     * 删除标签中的会话(从多个会话中批量删除指定标签)
     * @param tagId 标签id
     * @param conversations 要删除的会话列表
     */
    abstract removeTagForConversations(tagId: string, conversations: IConversationOption[]): IPromiseResult<IAsyncRes>;
    /**
     * 删除会话中的标签(从单一会话中批量删除标签)
     * @param conversationType 会话类型
     * @param targetId 会话id
     * @param tagIds 要删除的标签列表
     */
    abstract removeTagsForConversation(conversation: IConversationOption, tagIds: string[]): IPromiseResult<IAsyncRes>;
    /**
     * 获取标签下的会话列表
     * @param tagId 标签id
     */
    abstract getConversationListByTag(tagId: string, startTime: number, count?: number, channelId?: string): IPromiseResult<IReceivedConversationByTag[]>;
    /**
     * 获取标签下的未读消息数
     * @param tagId 标签id
     * @param containMuted 是否包含免打扰会话
     */
    abstract getUnreadCountByTag(tagId: string, containMuted: boolean): IPromiseResult<number>;
    /**
     * 设置标签中会话置顶
     * @param conversation 会话
     */
    abstract setConversationStatusInTag(tagId: string, conversation: IConversationOption, status: ITagStatus): IPromiseResult<IAsyncRes>;
    /**
     * 获取会话里的标签
     * @param config
     */
    abstract getTagsForConversation(conversation: IConversationOption): IPromiseResult<IConversationTag[]>;
    /**
     * 获取服务器时间
     */
    abstract getServerTime(): number;
    /**
     * 获取设备ID
     */
    abstract getDeviceId(): string;
    /**
     * 获取当前 userId
     */
    abstract getCurrentUserId(): string;
    /**
     * 设置用户在线状态监听器
    */
    abstract setUserStatusListener(config: {
        userIds: string[];
    }, listener: Function): void;
    /**
     * 设置当前用户在线状态
    */
    abstract setUserStatus(status: number): Promise<ErrorCode>;
    /**
     * 订阅用户在线状态
    */
    abstract subscribeUserStatus(userIds: string[]): Promise<ErrorCode>;
    /**
     * 获取用户状态
    */
    abstract getUserStatus(userId: string): IPromiseResult<{
        status: string;
    }>;
    /**
     * 清空所有会话
    */
    abstract clearConversations(conversationTypes?: ConversationType[], channelId?: string): Promise<ErrorCode>;
    /**
     * 加入黑名单
    */
    abstract addToBlacklist(userId: string): Promise<ErrorCode>;
    /**
      * 将指定用户移除黑名单
    */
    abstract removeFromBlacklist(userId: string): Promise<ErrorCode>;
    /**
      * 获取黑名单列表
    */
    abstract getBlacklist(): IPromiseResult<string[]>;
    /**
      * 获取指定人员在黑名单中的状态
    */
    abstract getBlacklistStatus(userId: string): IPromiseResult<string>;
    /**
     * 向本地插入一条消息，不发送到服务器
    */
    abstract insertMessage(conversationType: ConversationType, targetId: string, insertOptions: IInsertMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 删除本地消息
    */
    abstract deleteMessages(timestamps: number[]): Promise<ErrorCode>;
    /**
     * 通过时间戳删除本地消息
    */
    abstract deleteMessagesByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, cleanSpace: boolean, channelId: string): Promise<ErrorCode>;
    /**
     * 清空会话下历史消息
    */
    abstract clearMessages(conversationType: ConversationType, targetId: string, channelId: string): Promise<ErrorCode>;
    /**
     * 获取消息
    */
    abstract getMessage(messageId: number): IPromiseResult<IReceivedMessage>;
    /**
     * 设置消息内容
    */
    abstract setMessageContent(messageId: number, content: any, messageType: string): Promise<ErrorCode>;
    /**
     * 设置消息搜索字段
    */
    abstract setMessageSearchField(messageId: number, content: any, searchFiles: string): Promise<ErrorCode>;
    /**
     * 通过关键字搜索会话
    */
    abstract searchConversationByContent(keyword: string, customMessageTypes: string[], channelId: string, conversationTypes?: ConversationType[]): IPromiseResult<IReceivedConversation[]>;
    /**
     * 按内容搜索会话内的消息
    */
    abstract searchMessageByContent(conversationType: ConversationType, targetId: string, keyword: string, timestamp: number, count: number, total: number, channelId: string): IPromiseResult<{
        messages: IReceivedMessage[];
        count: number;
    }>;
    /**
     * 获取会话下所有未读的 @ 消息
    */
    abstract getUnreadMentionedMessages(conversationType: ConversationType, targetId: string, channelId: string): IReceivedMessage[];
    /**
     * 设置消息发送状态
    */
    abstract setMessageSentStatus(messageId: number, sentStatus: number): Promise<ErrorCode>;
    /**
     * 设置消息接收状态
    */
    abstract setMessageReceivedStatus(messageId: number, receivedStatus: number): Promise<ErrorCode>;
    /**
     * 删除时间戳前的未读数
    */
    abstract clearUnreadCountByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number, channelId: string): Promise<ErrorCode>;
    /**
     * 获取会话免打扰状态
    */
    abstract getConversationNotificationStatus(conversationType: ConversationType, targetId: string, channelId: string): IPromiseResult<NotificationStatus>;
    /**
     * 协议栈获取远端历史消息
    */
    abstract getRemoteHistoryMessages(conversationType: ConversationType, targetId: string, timestamp: number, count: number, order: 0 | 1, channelId: string): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    abstract joinRTCRoom(roomId: string, mode: RTCMode, broadcastType?: number, joinType?: RTCJoinType): IPromiseResult<IJoinRTCRoomData>;
    abstract quitRTCRoom(roomId: string): Promise<ErrorCode>;
    abstract rtcPing(roomId: string, mode: number, broadcastType?: number): Promise<ErrorCode>;
    abstract getRTCRoomInfo(roomId: string): IPromiseResult<IRTCRoomInfo>;
    abstract getRTCUserInfoList(roomId: string): IPromiseResult<IRTCUsers>;
    abstract getRTCUserInfo(roomId: string): IPromiseResult<unknown>;
    abstract setRTCUserInfo(roomId: string, key: string, value: string): Promise<ErrorCode>;
    abstract removeRTCUserInfo(roomId: string, keys: string[]): Promise<ErrorCode>;
    abstract setRTCData(roomId: string, key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    /**
     * 全量订阅资源修改
     * @param roomId 房间 Id
     * @param message 向前兼容的消息内容
     * @param valueInfo 全量资源数据
     * @param objectName 全量 URI 消息名
     */
    abstract setRTCTotalRes(roomId: string, message: {
        name: string;
        content: string;
    }, valueInfo: string, objectName: string, mcuValInfo: string): Promise<ErrorCode>;
    abstract getRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType): IPromiseResult<KVString>;
    abstract removeRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType, message?: {
        name: string;
        content: string;
    }): Promise<ErrorCode>;
    abstract setRTCOutData(roomId: string, rtcData: unknown, type: number, message: unknown): Promise<ErrorCode>;
    abstract getRTCOutData(roomId: string, userIds: string[]): IPromiseResult<unknown>;
    abstract getRTCToken(roomId: string, mode: number, broadcastType?: number): IPromiseResult<IRtcTokenData>;
    abstract setRTCState(roomId: string, reportId: string): Promise<ErrorCode>;
    abstract getRTCUserList(roomId: string): IPromiseResult<IRTCUsers>;
    abstract joinLivingRoomAsAudience(roomId: string, mode: RTCMode, broadcastType?: number): Promise<IAsyncRes<{
        token: string;
        kvEntries: IServerRTCRoomEntry[];
    }>>;
    abstract quitLivingRoomAsAudience(roomId: string): Promise<ErrorCode>;
    abstract rtcIdentityChange(roomId: string, changeType: RTCIdentityChangeType, broadcastType?: number): Promise<IAsyncRes<IJoinRTCRoomData>>;
    abstract getRTCJoinedUserInfo(userId: string): Promise<IAsyncRes<IRTCJoinedInfo[]>>;
    abstract setRTCCDNUris(roomId: string, objectName: string, CDNUris: string): Promise<ErrorCode>;
}

declare class AppStorage {
    private _cache;
    private _storageKey;
    private _rootStorage;
    constructor(runtime: IRuntime, suffix?: string);
    _get(): any;
    _set(cache: {
        [id: string]: any;
    }): void;
    set(key: string, value: any): void;
    remove(key: string): void;
    clear(): void;
    get(key: string): any;
    getKeys(): string[];
    getValues(): any;
}

declare class Todo extends Error {
    constructor(message: string);
}
declare const todo: (message: string) => Todo;

declare const appendUrl: (url: string, query?: {
    [key: string]: string | number | null;
} | undefined) => string;

/**
 * IndexDB中存储的log数据
 */
interface ILogInfo {
    sessionId: string;
    time: number;
    level: LogLevel;
    content: string;
    userId: string;
}
interface IRealTimeLog {
    level: LogLevel;
    content: string;
}

declare class Logger {
    readonly tag: string;
    readonly type?: LogType | undefined;
    private readonly initiator?;
    /**
     *
     * @param tag 标签
     * @param type 类型
     * @param initiator 发起方(A: APP 层，L: Lib 层)
     */
    constructor(tag: string, type?: LogType | undefined, initiator?: string | undefined);
    /**
     * 输出等级
     */
    private _outLevel;
    /**
     * 为向前兼容，暂不删除
     */
    private _stdout?;
    /**
     * 输出函数
     */
    private _logStdout?;
    /**
     * 本地存储日志列表
     */
    static databaseLogList: ILogInfo[];
    /**
     * 定时上传日志列表
     */
    static realTimeLogList: IRealTimeLog[];
    static readonly sessionId: string;
    static userId: string;
    static init(userId: string): void;
    static reset(): void;
    /**
     * 默认输出函数
     * @param level
     * @param args
     */
    private _defaultStdout;
    /**
     * 向 databaseLogList 中 push 日志
     * @param level 打印等级
     * @param content 日志内容
     * @param tag 日志tag
     */
    __pushLocalLog(level: LogLevel, content: string, tag: string): void;
    /**
     * 向数据库中插入 log 数据
     */
    __insertLogIntoDatabase(): Promise<boolean>;
    /**
     * 修改 log 输出等级
     * @param logLevel
     */
    setLogLevel(logLevel?: LogLevel): void;
    setLogStdout(stdout?: (level: LogLevel, content: string) => void): void;
    log(level: LogLevel, ...args: any[]): void;
    debug: (...args: any[]) => void;
    info: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
    fatal: (...args: any[]) => void;
    /**
     * 日志实时上报
     * @param level 日志等级
     * @param tag 日志标签
     * @param content 日志内容
     */
    reportLog(level: LogLevel, tag: string, content: string): void;
    /**
     * @deprecated
     * 函数已废弃，使用 `setLogLevel` 与 `setStdout` 方法替代
     */
    set(outLevel: LogLevel, stdout?: (level: LogLevel, ...args: any[]) => void): void;
    /**
     * 接口已废弃，改用 `setLogStdout`
     * @param stdout
     * @deprecated
     */
    setStdout(stdout?: (level: LogLevel, msgTag: string, ...args: any[]) => void): void;
    __clearRealTimeLog(): void;
}

declare type IEventListener = (...args: any[]) => void;
declare class EventEmitter {
    private readonly _map;
    /**
     * 添加事件监听器
     * @param eventType
     * @param listener
     */
    on(eventType: string, listener: IEventListener, target?: any): void;
    once(eventType: string, listener: IEventListener, target?: any): void;
    /**
     * 移除事件监听器
     * @param eventType
     * @param listener
     */
    off(eventType: string, listener: IEventListener, target?: any): void;
    /**
     * 事件派发
     * @param eventType
     * @param attrs
     */
    emit(eventType: string, ...attrs: any[]): void;
    /**
     * 清空所有指定类型的事件监听器
     * @param eventType
     */
    removeAll(eventType: string): void;
    /**
     * 无差别清空所有事件监听器
     */
    clear(): void;
}

declare class VersionManage {
    static add(name: string, version: string): void;
    /**
     * 校验当前 engine 版本是否大于等于所需版本，只校验前三位数字
     * @param version
     * @returns
    */
    static validEngine(version: string): boolean;
    static getInfo(): {
        [key: string]: string;
    };
}

/**
 * 检查参数是否为字符串
 * 只做类型检查，不做长度检查，故当字符串长度为 0，结果依然为 true
 * @param value
 */
declare const isString: (value: unknown) => boolean;
/**
 * 检测参数是否为布尔值
 * @param value
 */
declare const isBoolean: (value: unknown) => boolean;
/**
 * 检查参数是否为 number 数据
 * @param value
 */
declare const isNumber: (value: unknown) => boolean;
/**
 * 检查参数是否为数组
 * 只做类型检查，不做长度检查
 * 如 UnitArray、BufferArray 等也属于数组
 * @param arr
 */
declare const isArray: (arr: unknown) => boolean;
/**
 * 检查参数是否为 ArrayBuffer
 * @param arr
 */
declare const isArrayBuffer: (arr: unknown) => boolean;
/**
 * 检查参数是否为长度非 0 的字符串
 * @param str
 */
declare const notEmptyString: (str: string) => boolean;
/**
 * 检查参数是否为长度非 0 的数组
 * @param str
 */
declare const notEmptyArray: (arr: any[]) => boolean;
/**
 * 检查参数是否为对象
 * @param val
 */
declare const isObject: (val: any) => boolean;
/**
 * 检查参数是否为函数
 * @param val
 */
declare const isFunction: (val: any) => boolean;
/**
 * 检查参数是否为undefined
 * @param val
 */
declare const isUndefined: (val: any) => boolean;
/**
 * 检查参数是否为 null
*/
declare const isNull: (val: any) => boolean;
/**
 * 检查参数是否为有效 http(s) 协议 url
 * @param value
 */
declare const isHttpUrl: (value: any) => boolean;
/**
 * 检查对象不为空
 * @param val
*/
declare const notEmptyObject: (val: Object) => boolean;
declare const isValidConversationType: (conversation: number) => boolean;
/**
 * 判断是否是一个有效的文件类型
 */
declare const isValidFileType: (fileType: number) => boolean;

/**
 * 预定义的验证规则，只包含`值类型`数据验证
 * 引用类型数据需使用自定义 validator 校验函数进行校验
 */
declare enum AssertRules {
    /**
     * 类型为字符串，且长度大于 0
     */
    STRING = 0,
    /**
     * 类型仅为 String
    */
    ONLY_STRING = 1,
    /**
     * 类型为数字
     */
    NUMBER = 2,
    /**
     * 类型为布尔值
     */
    BOOLEAN = 3,
    /**
     * 类型为对象
    */
    OBJECT = 4,
    /**
     * 类型为数组
    */
    ARRAY = 5,
    /**
     * 类型为 callback 回调对象，包含 callback.onSuccess、callback.onError
    */
    CALLBACK = 6
}
declare class RCAssertError extends Error {
    constructor(message?: string);
}
/**
 * 参数校验，该方法用于对业务层入参数据检查，及时抛出异常通知业务层进行修改
 * @description
 * 1. 必填参数，value 需符合 validator 验证规，否则抛出异常
 * 2. 非必填参数，value 可为 undefined | null 或符合 validator 规则
 * @param key 字段名，仅用于验证失败时给出提示信息
 * @param value 待验证的值
 * @param validator 期望类型或校验规则函数，若使用规则函数
 * @param required 是否为必填参数，默认为 `false`
 */
declare const assert: (key: string, value: any, validator: AssertRules | ((value: any) => boolean), required?: boolean) => void;
/**
 * 参数校验，该方法用于对业务层入参数据检查，与 `assert` 函数不同的是其返回 boolean 值而非直接抛出异常
 * @description
 * 1. 必填参数，value 需符合 validator 验证规，否则抛出异常
 * 2. 非必填参数，value 可为 undefined | null 或符合 validator 规则
 * @param key 字段名，仅用于验证失败时给出提示信息
 * @param value 待验证的值
 * @param validator 期望类型或校验规则函数，若使用规则函数
 * @param required 是否为必填参数，默认为 `false`
 */
declare const validate: (key: string, value: any, validator: AssertRules | ((value?: any) => boolean), required?: boolean) => boolean;

/**
 * engine 层业务相关工具方法
*/

/**
 * 通过文件类型生成上传唯一文件名
*/
declare const getUploadFileName: (type: number, fileName?: string | undefined) => string;
/**
 * 通过 fileType 获取 MIME
*/
declare const getMimeKey: (fileType: FileType) => string;
/**
 * 生成 pushConfigs JSON
 * @description
 * 与 Server 约定一致， threadId、apnsCollapseId、channelIdMi、channelIdHW、channelIdOPPO、typeVivo 无值时可传空字符串
*/
declare const pushConfigsToJSON: (iOSConfig?: IiOSPushConfig, androidConfig?: IAndroidPushConfig) => string;
/**
 * 将服务端返回的 push 信息格式化
 * @param pushStr
 */
declare const pushJSONToConfigs: (pushStr: string, pushId: string) => {
    iOSConfig: IiOSPushConfig;
    androidConfig: IAndroidPushConfig;
};
declare const isValidChrmEntryKey: (key: string) => Boolean;
declare const isValidChrmEntryValue: (value: string) => Boolean;

/**
 * @todo 后期禁用此方法，容易滥用，且会丢失上下文的数据类型跟踪
 * @deprecated
 * @param source
 * @param event
 * @param options
 */
declare const forEach: (source: any, event: Function, options?: any) => void;
/**
 * @deprecated
 * @param source
 * @param event
 */
declare const map: (source: any[], event: Function) => any[];
declare const indexOf: (source: any[] | string, searchVal: any) => number;
declare const isInclude: (source: string | any[], searchVal: any) => boolean;
/**
 * 判断对象里是否有某个值
*/
declare const isInObject: (source: Object, searchVal: any) => boolean;
/**
 * 通过 JSON 拷贝
*/
declare const cloneByJSON: <T>(sourceObj: T) => T;
/**
 * 判断当前是否运行在 electron 环境且搭配 c++ 协议栈使用
 */
declare const usingCppEngine: () => boolean;
declare const getBrowser: (runtime: IRuntime) => {
    type: any;
    version: any;
};
/**
 * 将连接时服务端返回码转换成业务响应码
 * @param code 连接响应码
 */
declare const formatConnectResponseCode: (code: number) => ErrorCode;

/**
 * Navi 缓存数据有效时长，单位毫秒
 */
declare const NAVI_CACHE_DURATION: number;
/**
 * 单个 Navi 请求的超时时间，单位毫秒
 */
declare const NAVI_REQ_TIMEOUT: number;
/**
 * /ping?r= 请求的超时时间，单位毫秒
 */
declare const PING_REQ_TIMEOUT: number;
/**
 * WebSocket 建立连接超时时间，单位毫秒
 */
declare const WEB_SOCKET_TIMEOUT: number;
/**
 * 公有云 Navi 请求地址
 */
declare const PUBLIC_CLOUD_NAVI_URIS: string[];
/**
 * 小程序 websocket 连接地址
 */
declare const MINI_SOCKET_CONNECT_URIS: string[];
/**
 * 小程序 长轮询 连接地址
 */
declare const MINI_COMET_CONNECT_URIS: string[];
/**
 * IM 接口超时时间，单位毫秒
 */
declare const IM_SIGNAL_TIMEOUT: number;
/**
 * IM Ping 间隔时间，单位毫秒
 */
declare const IM_PING_INTERVAL_TIME: number;
/**
 * IM Ping 超时时间，单位毫秒
 */
declare const IM_PING_TIMEOUT: number;
/**
 * IM Ping 最小超时时间，单位毫秒
 */
declare const IM_PING_MIN_TIMEOUT: number;
/**
 * 消息 content 内容尺寸限制：128 KB
 */
declare const MAX_MESSAGE_CONTENT_BYTES: number;
/**
 * IM Comet 发送 pullmsg(嗅探 + 等待信令) 超时时间 45s
 */
declare const IM_COMET_PULLMSG_TIMEOUT = 45000;
/**
 * storage key 使用的前缀
*/
declare const STORAGE_ROOT_KEY = "RCV4-";
declare const SEND_MESSAGE_TYPE_OPTION: {
    [key: string]: {
        isCounted: boolean;
        isPersited: boolean;
    };
};
/**
 * 协议栈内置消息类型
 * TODO: 需确认是否添加到 Web 中
*/
declare const CPP_PROTOCAL_MSGTYPE_OPTION: {
    [key: string]: {
        isCounted: boolean;
        isPersited: boolean;
    };
};
/**
 * 状态消息(不存储，不计数，并且上线后不会拉取离线的状态消息)
 */
declare const STATUS_MESSAGE: string[];
/**
 * 连接类型
 */
declare enum CONNECTION_TYPE {
    WEBSOCKET = "websocket",
    COMET = "comet"
}

/**
 * engine 版本号
 */
declare const version: string;

export { AEngine, ANavi, APIContext, AppStorage, AssertRules, CONNECTION_TYPE, CPP_PROTOCAL_MSGTYPE_OPTION, CallLibMsgType, ChatroomEntryType, ChatroomUserChangeType as ChatroomMemberChangeType, CometChannel, ConnectResultCode, ConnectionStatus, ConversationType, DelayTimer, ErrorCode, EventEmitter, FileType, HttpMethod, IAPIContextOption, IAsyncRes, IBlockedMessageInfo, IChatroomEntries, IChatroomEntry, IChatroomInfo, IChatroomListener, IChatroomListenerData, IChrmKVEntries, IChrmKVEntry, IConnectResult, IConnectionStatusListener, IConversationOption, IConversationStateListener, IConversationTag, IConversationTagListener, IDataChannelWatcher, IDeletedExpansion, IEngine, IEngineWatcher, IExpansionListener, IExpansionListenerData, IExpansionMsgContent, IExtraMethod, IInsertMsgOptions, IJoinRTCRoomData, ILocalReadReceiptInfo, ILocalTagStatus, IM_COMET_PULLMSG_TIMEOUT, IM_PING_INTERVAL_TIME, IM_PING_MIN_TIMEOUT, IM_PING_TIMEOUT, IM_SIGNAL_TIMEOUT, IMessageBlockedListener, IMessageListnenr, IMessageReader, IMessageReaderResponse, IMetionedData, INaviInfo, IPluginGenerator, IPromiseResult, IPushConfig, IRTCInnerListener, IRTCJoinedInfo, IRTCRoomInfo, IRTCUsers, IReadReceiptInfo, IRecallMsgOptions, IReceivedConversation, IReceivedConversationByTag, IReceivedMessage, IRemoveChatRoomEntriesOption, IRemoveChatRoomEntryOption, IRequest, IResponse, IRtcTokenData, IRuntime, ISendExMsgOptions, ISendMsgOptions, IServerConversationStatus, IServerRTCRoomEntry, IServerUserSetting, ISetConversationStatusOptions, IStorage, ITagInfo, ITagListener, ITagParam, ITagStatus, ITypingInfo, ITypingMessage, ITypingUser, IUpdatedConversation, IUpdatedExpansion, IUploadAuth, IUserProfile, IWatcher, IWebSocket, ItypingStateListener, KVString, LiveRole, LiveType, LogLevel, LogType, Logger, MAX_MESSAGE_CONTENT_BYTES, MINI_COMET_CONNECT_URIS, MINI_SOCKET_CONNECT_URIS, MentionedType, MessageDirection, MessageType, NAVI_CACHE_DURATION, NAVI_REQ_TIMEOUT, NotificationStatus, PING_REQ_TIMEOUT, PUBLIC_CLOUD_NAVI_URIS, PluginContext, RCAssertError, RTCApiType, RTCIdentityChangeType, RTCJoinType, RTCMode, RTCPluginContext, ReceivedStatus, SEND_MESSAGE_TYPE_OPTION, STATUS_MESSAGE, STORAGE_ROOT_KEY, TagChangeType, UploadMethod, VersionManage, WEB_SOCKET_TIMEOUT, WebSocketChannel, appendUrl, assert, cloneByJSON, forEach, formatConnectResponseCode, getBrowser, getMimeKey, getUploadFileName, indexOf, isArray, isArrayBuffer, isBoolean, isFunction, isHttpUrl, isInObject, isInclude, isNull, isNumber, isObject, isString, isUndefined, isValidChrmEntryKey, isValidChrmEntryValue, isValidConversationType, isValidFileType, map, notEmptyArray, notEmptyObject, notEmptyString, pushConfigsToJSON, pushJSONToConfigs, todo, usingCppEngine, validate, version };
